# streamlit_app.py (RU, preloaded, simplified UI)
# -------------------------------------------------------------
# –ê–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Ä–æ–¥–æ—Å–ª–æ–≤–Ω—ã—Ö (–±–µ–∑ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤)
# –î–∞–Ω–Ω—ã–µ –±–µ—Ä—É—Ç—Å—è –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–π –ø–∞–ø–∫–∏ ./db_lineages (–≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏).
# –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –Ω–∞ —Ä—É—Å—Å–∫–æ–º, –±–µ–∑ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≤ —Å–∞–π–¥–±–∞—Ä–µ.
# -------------------------------------------------------------

from __future__ import annotations

import csv
import io
import json
import os
import re
import textwrap
from datetime import datetime
from pathlib import Path
from typing import Callable, Dict, List, Literal, Optional, Set, Tuple
    
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import pandas as pd
import streamlit as st
from urllib.parse import urlencode, urlsplit
try:
    import openpyxl
except ImportError:
    openpyxl = None
try:
    from streamlit.runtime.scriptrunner import get_script_run_ctx
except Exception:  # pragma: no cover - —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏ –≤–µ—Ä—Å–∏—è–º–∏ streamlit
    get_script_run_ctx = None  # type: ignore
import zipfile
from pyvis.network import Network
from sklearn.metrics import silhouette_samples, silhouette_score

from school_comparison_tab import render_school_comparison_tab

from school_comparison_new_tab import render_school_comparison_new_tab

# ---------------------- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã -----------------------------------------
DATA_DIR = "db_lineages"      # –ø–∞–ø–∫–∞ —Å CSV –≤–Ω—É—Ç—Ä–∏ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
CSV_GLOB = "*.csv"            # –∫–∞–∫–∏–µ —Ñ–∞–π–ª—ã –±—Ä–∞—Ç—å
AUTHOR_COLUMN = "candidate_name"
SUPERVISOR_COLUMNS = [f"supervisors_{i}.name" for i in (1, 2)]

BASIC_SCORES_DIR = "basic_scores"  # —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ—Ñ–∏–ª–∏ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π

FEEDBACK_FILE = Path("feedback.csv")
FEEDBACK_FORM_STATE_KEY = "feedback_form_state"
FEEDBACK_FORM_RESULT_KEY = "feedback_form_result"

# –ü—É–±–ª–∏—á–Ω—ã–π –∞–¥—Ä–µ—Å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Å—ã–ª–æ–∫ "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è".
# –ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –µ–≥–æ –º–æ–∂–Ω–æ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è
# PUBLIC_APP_URL.
PUBLIC_APP_URL = os.environ.get(
    "PUBLIC_APP_URL",
    "https://academic-genealogy.streamlit.app/",
).strip().rstrip("/")

# ---------------------- –¢–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä ------------------------
ClassifierItem = Tuple[str, str, bool]

THEMATIC_CLASSIFIER: List[ClassifierItem] = [
    ("1.1", "–°—Ä–µ–¥–∞ –∏ –ø—Ä–µ–¥–º–µ—Ç–Ω–∞—è –æ–±–ª–∞—Å—Ç—å", True),
    ("1.1.1", "–£—Ä–æ–≤–µ–Ω—å —Ñ–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è", True),
    ("1.1.1.1", "–î–æ—à–∫–æ–ª—å–Ω–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ", False),
    ("1.1.1.2", "–®–∫–æ–ª—å–Ω–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ", False),
    ("1.1.1.2.1", "–ù–∞—á–∞–ª—å–Ω–æ–µ –æ–±—â–µ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ", False),
    ("1.1.1.2.2", "–û—Å–Ω–æ–≤–Ω–æ–µ –æ–±—â–µ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ", False),
    ("1.1.1.2.3", "–°—Ä–µ–¥–Ω–µ–µ –æ–±—â–µ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ", False),
    ("1.1.1.3", "–°—Ä–µ–¥–Ω–µ–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ (–°–ü–û)", False),
    ("1.1.1.4", "–í—ã—Å—à–µ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ", False),
    ("1.1.1.4.1", "–í—ã—Å—à–µ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ ‚Äì –ë–∞–∫–∞–ª–∞–≤—Ä–∏–∞—Ç", False),
    ("1.1.1.4.2", "–í—ã—Å—à–µ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ ‚Äì –°–ø–µ—Ü–∏–∞–ª–∏—Ç–µ—Ç", False),
    ("1.1.1.4.3", "–í—ã—Å—à–µ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ ‚Äì –ú–∞–≥–∏—Å—Ç—Ä–∞—Ç—É—Ä–∞", False),
    ("1.1.1.5", "–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–∞–¥—Ä–æ–≤ –≤—ã—Å—à–µ–π –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏–∏", False),
    ("1.1.1.5.1", "–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–∞–¥—Ä–æ–≤ –≤—ã—Å—à–µ–π –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏–∏ ‚Äì –ê—Å–ø–∏—Ä–∞–Ω—Ç—É—Ä–∞", False),
    ("1.1.1.5.2", "–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–∞–¥—Ä–æ–≤ –≤—ã—Å—à–µ–π –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏–∏ ‚Äì –û—Ä–¥–∏–Ω–∞—Ç—É—Ä–∞", False),
    ("1.1.1.6", "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ", False),
    ("1.1.1.6.1", "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ ‚Äì –ü–æ–≤—ã—à–µ–Ω–∏–µ –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏–∏", False),
    ("1.1.1.6.2", "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ ‚Äì –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞", False),
    ("1.1.1.7", "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–µ—Ç–µ–π –∏ –≤–∑—Ä–æ—Å–ª—ã—Ö", False),
    ("1.1.1.8", "–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ", False),
    ("1.1.2", "–ü—Ä–µ–¥–º–µ—Ç–Ω—ã–π —Ü–∏–∫–ª / –û–±–ª–∞—Å—Ç—å –∑–Ω–∞–Ω–∏—è", True),
    ("1.1.2.1", "–ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –∏ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–Ω–∞—É—á–Ω—ã–µ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω—ã", False),
    ("1.1.2.1.1", "–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞", False),
    ("1.1.2.1.2", "–ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞", False),
    ("1.1.2.1.3", "–§–∏–∑–∏–∫–∞", False),
    ("1.1.2.1.4", "–•–∏–º–∏—è", False),
    ("1.1.2.1.5", "–ë–∏–æ–ª–æ–≥–∏—è", False),
    ("1.1.2.1.6", "–î—Ä—É–≥–∏–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–Ω–∞—É—á–Ω—ã–µ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω—ã", False),
    ("1.1.2.2", "–ì—É–º–∞–Ω–∏—Ç–∞—Ä–Ω—ã–µ –∏ —Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω—ã", False),
    ("1.1.2.2.1", "–§–∏–ª–æ–ª–æ–≥–∏—è", False),
    ("1.1.2.2.1.1", "–Ø–∑—ã–∫–∏", False),
    ("1.1.2.2.1.1.1", "–†—É—Å—Å–∫–∏–π —è–∑—ã–∫", False),
    ("1.1.2.2.1.1.2", "–Ø–∑—ã–∫ –Ω–∞—Ä–æ–¥–æ–≤ –†–æ—Å—Å–∏–∏", False),
    ("1.1.2.2.1.1.3", "–ò–Ω–æ—Å—Ç—Ä–∞–Ω–Ω—ã–π —è–∑—ã–∫", False),
    ("1.1.2.2.1.1.3.1", "–ê–Ω–≥–ª–∏–π—Å–∫–∏–π —è–∑—ã–∫", False),
    ("1.1.2.2.1.1.3.2", "–ù–µ–º–µ—Ü–∫–∏–π —è–∑—ã–∫", False),
    ("1.1.2.2.1.1.3.3", "–§—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π —è–∑—ã–∫", False),
    ("1.1.2.2.1.1.3.4", "–ò–Ω–æ–π –∏–Ω–æ—Å—Ç—Ä–∞–Ω–Ω—ã–π —è–∑—ã–∫", False),
    ("1.1.2.2.1.2", "–õ–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞", False),
    ("1.1.2.2.2", "–ò—Å—Ç–æ—Ä–∏—è", False),
    ("1.1.2.2.3", "–û–±—â–µ—Å—Ç–≤–æ–∑–Ω–∞–Ω–∏–µ, —Å–æ—Ü–∏–æ–ª–æ–≥–∏—è", False),
    ("1.1.2.2.4", "–°–æ—Ü–∏–∞–ª—å–Ω–æ-—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∞—è –≥–µ–æ–≥—Ä–∞—Ñ–∏—è", False),
    ("1.1.2.2.5", "–≠–∫–æ–Ω–æ–º–∏–∫–∞", False),
    ("1.1.2.2.6", "–ü—Ä–∞–≤–æ", False),
    ("1.1.2.2.7", "–î—Ä—É–≥–∏–µ –≥—É–º–∞–Ω–∏—Ç–∞—Ä–Ω—ã–µ –∏ –æ–±—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω—ã", False),
    ("1.1.2.3", "–ò–∑–æ–±—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ–µ –∏ –º—É–∑—ã–∫–∞–ª—å–Ω–æ–µ –∏—Å–∫—É—Å—Å—Ç–≤–æ", False),
    ("1.1.2.4", "–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—è", False),
    ("1.1.2.5", "–§–∏–∑–∏—á–µ—Å–∫–∞—è –∫—É–ª—å—Ç—É—Ä–∞ –∏ —Å–ø–æ—Ä—Ç", False),
    ("1.1.2.6", "–ò–Ω–∂–µ–Ω–µ—Ä–Ω–æ-—Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ", False),
    ("1.1.2.7", "–ü—Å–∏—Ö–æ–ª–æ–≥–æ-–ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ", False),
    ("1.1.2.8", "–ú–µ–∂–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞—Ä–Ω—ã–µ –∏ –Ω–∞–¥–ø—Ä–µ–¥–º–µ—Ç–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏", False),
    ("1.2", "–°—É–±—ä–µ–∫—Ç –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è (–∫–æ–≥–æ—Ä—Ç–∞)", True),
    ("1.2.1", "–°–æ—Ü–∏–∞–ª—å–Ω–æ-–ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≥—Ä—É–ø–ø–∞", True),
    ("1.2.1.1", "–û–±—É—á–∞—é—â–∏–µ—Å—è –æ–±—â–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π", False),
    ("1.2.1.2", "–°—Ç—É–¥–µ–Ω—Ç—ã –∫–æ–ª–ª–µ–¥–∂–µ–π –∏ —Ç–µ—Ö–Ω–∏–∫—É–º–æ–≤ (–°–ü–û)", False),
    ("1.2.1.3", "–°—Ç—É–¥–µ–Ω—Ç—ã –≤—É–∑–æ–≤ (–í–û)", False),
    ("1.2.1.4", "–î–µ–π—Å—Ç–≤—É—é—â–∏–µ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—ã (–≤ —Å–∏—Å—Ç–µ–º–µ –î–ü–û)", False),
    ("1.2.1.5", "–ü–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–∏–µ –∏ –Ω–∞—É—á–Ω—ã–µ –∫–∞–¥—Ä—ã (–∫–∞–∫ –æ–±—ä–µ–∫—Ç —Ä–∞–∑–≤–∏—Ç–∏—è)", False),
    ("1.2.1.6", "–í–æ–µ–Ω–Ω–æ—Å–ª—É–∂–∞—â–∏–µ / —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∏ —Å–∏–ª–æ–≤—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä", False),
    ("1.2.1.7", "–°–ø–æ—Ä—Ç—Å–º–µ–Ω—ã", False),
    ("1.2.2", "–°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç–∏", True),
    ("1.2.2.1", "–û–±—É—á–∞—é—â–∏–µ—Å—è —Å –û–í–ó –∏/–∏–ª–∏ –∏–Ω–≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å—é", False),
    ("1.2.2.2", "–û–¥–∞—Ä–µ–Ω–Ω—ã–µ –∏ –≤—ã—Å–æ–∫–æ–º–æ—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–±—É—á–∞—é—â–∏–µ—Å—è", False),
    ("1.2.2.3", "–û–±—É—á–∞—é—â–∏–µ—Å—è –∏–∑ –≥—Ä—É–ø–ø —Å–æ—Ü–∏–∞–ª—å–Ω–æ–≥–æ —Ä–∏—Å–∫–∞", False),
    ("1.2.2.4", "–ò–Ω–æ—Ñ–æ–Ω—ã / –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –º–∏–≥—Ä–∞–Ω—Ç—ã", False),
    ("2.1", "–¢–∏–ø –∏ –º–∞—Å—à—Ç–∞–± —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è", True),
    ("2.1.1", "–£—Ä–æ–≤–µ–Ω—å –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏", True),
    ("2.1.1.1", "–¢–µ–æ—Ä–µ—Ç–∏–∫–æ-–º–µ—Ç–æ–¥–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –∫–æ–Ω—Ü–µ–ø—Ü–∏—è", False),
    ("2.1.1.2", "–°—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ-—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å", False),
    ("2.1.1.3", "–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω–æ-–ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞", False),
    ("2.1.1.4", "–ü–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–∞—è —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è", False),
    ("2.1.1.5", "–ß–∞—Å—Ç–Ω–∞—è –º–µ—Ç–æ–¥–∏–∫–∞ –ø—Ä–µ–ø–æ–¥–∞–≤–∞–Ω–∏—è", False),
    ("2.1.1.6", "–ö–æ–º–ø–ª–µ–∫—Å –ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–∏—Ö —É—Å–ª–æ–≤–∏–π", False),
    ("2.1.1.7", "–û–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è/–≤–æ—Å–ø–∏—Ç–∞—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞", False),
    ("2.1.2", "–î–æ–º–∏–Ω–∏—Ä—É—é—â–∞—è –ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–∞—è –ø–∞—Ä–∞–¥–∏–≥–º–∞", True),
    ("2.1.2.1", "–ó–Ω–∞–Ω–∏–µ–≤–∞—è (—Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–∞—è)", False),
    ("2.1.2.2", "–ö–æ–º–ø–µ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–Ω–∞—è", False),
    ("2.1.2.3", "–°–∏—Å—Ç–µ–º–Ω–æ-–¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–Ω–∞—è", False),
    ("2.1.2.4", "–õ–∏—á–Ω–æ—Å—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è / –ì—É–º–∞–Ω–∏—Å—Ç–∏—á–µ—Å–∫–∞—è", False),
    ("2.1.2.5", "–ê–∫—Å–∏–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è (—Ü–µ–Ω–Ω–æ—Å—Ç–Ω–∞—è)", False),
    ("2.1.2.6", "–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∞—è / –ü—Ä–æ–±–ª–µ–º–Ω–∞—è", False),
    ("2.2", "–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ –∏ –º–µ—Ç–æ–¥—ã –ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—è", True),
    ("2.2.1", "–í–µ–¥—É—â–∞—è —Ñ–æ—Ä–º–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏", True),
    ("2.2.1.1", "–†–µ–ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–∞—è —É—á–µ–±–Ω–∞—è –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å", False),
    ("2.2.1.2", "–ü—Ä–æ–µ–∫—Ç–Ω–∞—è –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å", False),
    ("2.2.1.3", "–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å", False),
    ("2.2.1.4", "–ò–≥—Ä–æ–≤–∞—è –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–¥–∏–¥–∞–∫—Ç–∏—á–µ—Å–∫–∞—è, –¥–µ–ª–æ–≤–∞—è, —Ä–æ–ª–µ–≤–∞—è)", False),
    ("2.2.1.5", "–î–∏—Å–∫—É—Å—Å–∏–æ–Ω–Ω—ã–µ —Ñ–æ—Ä–º—ã (–¥–∏—Å–∫—É—Å—Å–∏—è, –¥–µ–±–∞—Ç—ã)", False),
    ("2.2.1.6", "–•—É–¥–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ-—Ç–≤–æ—Ä—á–µ—Å–∫–∞—è –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å", False),
    ("2.2.1.7", "–°–ø–æ—Ä—Ç–∏–≤–Ω–æ-—Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω–∞—è –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å", False),
    ("2.2.2", "–ò—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ –æ–±—É—á–µ–Ω–∏—è", True),
    ("2.2.2.1", "–¢–µ–∫—Å—Ç–æ–≤—ã–µ –∏ –ø–µ—á–∞—Ç–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ (—É—á–µ–±–Ω–∏–∫, —Ä–∞–±–æ—á–∞—è —Ç–µ—Ç—Ä–∞–¥—å)", False),
    ("2.2.2.2", "–ê—É–¥–∏–æ–≤–∏–∑—É–∞–ª—å–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ (–≤–∏–¥–µ–æ, –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏)", False),
    ("2.2.2.3", "–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ —Ü–∏—Ñ—Ä–æ–≤—ã–µ —Ä–µ—Å—É—Ä—Å—ã (—Ç—Ä–µ–Ω–∞–∂–µ—Ä—ã, —Å–∏–º—É–ª—è—Ç–æ—Ä—ã, –≠–û–†)", False),
    ("2.2.2.4", "–°—Ä–µ–¥—Å—Ç–≤–∞ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π –∏ –¥–æ–ø–æ–ª–Ω–µ–Ω–Ω–æ–π —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ (VR/AR)", False),
    ("2.2.2.5", "–ü–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è (LMS, –æ–Ω–ª–∞–π–Ω-–∫—É—Ä—Å—ã)", False),
    ("2.2.2.6", "–°—Ä–µ–¥—Å—Ç–≤–∞ –≥–µ–π–º–∏—Ñ–∏–∫–∞—Ü–∏–∏", False),
    ("2.2.3", "–î–æ–º–∏–Ω–∏—Ä—É—é—â–∏–π —Ç–∏–ø –ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è", True),
    ("2.2.3.1", "–ü—Ä—è–º–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–∏–Ω—Å—Ç—Ä—É–∫—Ç–∞–∂, –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ)", False),
    ("2.2.3.2", "–§–∞—Å–∏–ª–∏—Ç–∞—Ü–∏—è / –ú–æ–¥–µ—Ä–∞—Ü–∏—è", False),
    ("2.2.3.3", "–¢—å—é—Ç–æ—Ä—Å–∫–æ–µ —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ / –ù–∞—Å—Ç–∞–≤–Ω–∏—á–µ—Å—Ç–≤–æ", False),
    ("2.2.3.4", "–ö–æ–Ω—Å—É–ª—å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ", False),
    ("3.1", "–ö–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è —Å—Ñ–µ—Ä–∞", True),
    ("3.1.1", "–ü—Ä–µ–¥–º–µ—Ç–Ω—ã–µ –∑–Ω–∞–Ω–∏—è –∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è", False),
    ("3.1.2", "–ú–µ—Ç–æ–¥–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –∑–Ω–∞–Ω–∏—è", False),
    ("3.1.3", "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –º—ã—à–ª–µ–Ω–∏–µ", False),
    ("3.1.4", "–ö—Ä–µ–∞—Ç–∏–≤–Ω–æ–µ (—Ç–≤–æ—Ä—á–µ—Å–∫–æ–µ) –º—ã—à–ª–µ–Ω–∏–µ", False),
    ("3.1.5", "–°–∏—Å—Ç–µ–º–Ω–æ–µ / –ü—Ä–æ–µ–∫—Ç–Ω–æ–µ –º—ã—à–ª–µ–Ω–∏–µ", False),
    ("3.1.6", "–ù–∞—É—á–Ω–æ–µ / –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –º–∏—Ä–æ–≤–æ–∑–∑—Ä–µ–Ω–∏–µ", False),
    ("3.2", "–î–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–Ω–æ-–ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Å—Ñ–µ—Ä–∞", True),
    ("3.2.1", "–ü—Ä–µ–¥–º–µ—Ç–Ω—ã–µ —É–º–µ–Ω–∏—è –∏ –Ω–∞–≤—ã–∫–∏ (Hard Skills)", False),
    ("3.2.2", "–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ –Ω–∞–≤—ã–∫–∏ (Soft Skills)", False),
    ("3.2.2.1", "–ö–æ–º–º—É–Ω–∏–∫–∞—Ç–∏–≤–Ω—ã–µ –Ω–∞–≤—ã–∫–∏", False),
    ("3.2.2.2", "–ù–∞–≤—ã–∫–∏ –∫–æ–æ–ø–µ—Ä–∞—Ü–∏–∏ –∏ —Ä–∞–±–æ—Ç—ã –≤ –∫–æ–º–∞–Ω–¥–µ", False),
    ("3.2.2.3", "–ù–∞–≤—ã–∫–∏ —Å–∞–º–æ–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –∏ —Ç–∞–π–º-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞", False),
    ("3.2.2.4", "–ù–∞–≤—ã–∫–∏ —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º (problem-solving)", False),
    ("3.2.3", "–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∫–æ–º–ø–µ—Ç–µ–Ω—Ü–∏–∏", False),
    ("3.2.4", "–ú–µ—Ç–∞–ø—Ä–µ–¥–º–µ—Ç–Ω—ã–µ / –ö–ª—é—á–µ–≤—ã–µ –∫–æ–º–ø–µ—Ç–µ–Ω—Ü–∏–∏", False),
    ("3.2.5", "–°–æ—Ü–∏–∞–ª—å–Ω–∞—è –∫–æ–º–ø–µ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å", False),
    ("3.3", "–õ–∏—á–Ω–æ—Å—Ç–Ω–æ-—Ü–µ–Ω–Ω–æ—Å—Ç–Ω–∞—è —Å—Ñ–µ—Ä–∞", True),
    ("3.3.1", "–ú–æ—Ç–∏–≤–∞—Ü–∏—è (—É—á–µ–±–Ω–∞—è, –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è)", False),
    ("3.3.2", "–¶–µ–Ω–Ω–æ—Å—Ç–Ω—ã–µ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏", False),
    ("3.3.3", "–í–æ–ª–µ–≤–∞—è —Å–∞–º–æ—Ä–µ–≥—É–ª—è—Ü–∏—è", False),
    ("3.3.4", "–†–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω—ã–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏", False),
    ("3.3.5", "–ò–Ω—Ç–µ–≥—Ä–∞—Ç–∏–≤–Ω—ã–µ –ª–∏—á–Ω–æ—Å—Ç–Ω—ã–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç—ã", True),
    ("3.3.5.1", "–ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å (–∫ –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, —Å–∞–º–æ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—é –∏ –¥—Ä.)", False),
    ("3.3.5.2", "–°—É–±—ä–µ–∫—Ç–Ω–æ—Å—Ç—å / –°—É–±—ä–µ–∫—Ç–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è", False),
    ("3.3.5.3", "–ò–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å (–ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è, –≥—Ä–∞–∂–¥–∞–Ω—Å–∫–∞—è)", False),
    ("3.3.5.4", "–ü–∞—Ç—Ä–∏–æ—Ç–∏–∑–º / –ì—Ä–∞–∂–¥–∞–Ω—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å", False),
    ("3.3.6", "–§–æ—Ä–º–∏—Ä—É–µ–º—ã–π —Ç–∏–ø –∫—É–ª—å—Ç—É—Ä—ã –ª–∏—á–Ω–æ—Å—Ç–∏", True),
    ("3.3.6.1", "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –∫—É–ª—å—Ç—É—Ä–∞", False),
    ("3.3.6.2", "–ü—Ä–∞–≤–æ–≤–∞—è –∫—É–ª—å—Ç—É—Ä–∞", False),
    ("3.3.6.3", "–≠–∫–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –∫—É–ª—å—Ç—É—Ä–∞", False),
    ("3.3.6.4", "–§–∏–∑–∏—á–µ—Å–∫–∞—è –∫—É–ª—å—Ç—É—Ä–∞", False),
    ("3.3.6.5", "–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –∫—É–ª—å—Ç—É—Ä–∞", False),
    ("3.3.6.6", "–ö—É–ª—å—Ç—É—Ä–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∂–∏–∑–Ω–µ–¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏", False),
]

CLASSIFIER_BY_CODE: Dict[str, ClassifierItem] = {
    code: (code, title, disabled) for code, title, disabled in THEMATIC_CLASSIFIER
}

PROFILE_SELECTION_SESSION_KEY = "profile_selected_codes"
PROFILE_SELECTION_LIMIT = 5
PROFILE_MIN_SCORE = 4.0


def classifier_depth(code: str) -> int:
    return code.count(".") if code else 0


def classifier_format(option: Optional[ClassifierItem]) -> str:
    if option is None:
        return "‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ –ø—É–Ω–∫—Ç ‚Äî"
    code, title, disabled = option
    indent = "\u2003" * classifier_depth(code)
    label = f"{code} {title}"
    if disabled:
        label += " (–Ω–µ–ª—å–∑—è –≤—ã–±—Ä–∞—Ç—å)"
    return f"{indent}{label}"


def classifier_label(code: str) -> str:
    item = CLASSIFIER_BY_CODE.get(code)
    if not item:
        return code
    _, title, _ = item
    return f"{code} ¬∑ {title}"

# ---------------------- –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –¥–ª—è –≤–∫–ª–∞–¥–æ–∫ ---------------------------------

INSTRUCTIONS = {
    "lineages": """
## –í–∫–ª–∞–¥–∫–∞ ¬´–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤—å–µ–≤¬ª

–ù–∞ —ç—Ç–æ–π –≤–∫–ª–∞–¥–∫–µ –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç—Å—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤—å–µ–≤ –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–∞ (—Å–≤—è–∑—å ¬´–Ω–∞—É—á–Ω—ã–π —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å/–∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç ‚Äì –¥–∏—Å—Å–µ—Ä—Ç–∞–Ω—Ç¬ª). –í–æ–∑–º–æ–∂–Ω–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤—å–µ–≤ –¥–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –Ω–∞—É—á–Ω—ã—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π. –í–æ–∑–º–æ–∂–Ω—ã –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –Ω–µ—Ç–æ—á–Ω–æ—Å—Ç–∏ –≤ —Å–ª—É—á–∞–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –§–ò–û —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –∏–ª–∏ –¥–∏—Å—Å–µ—Ä—Ç–∞–Ω—Ç–æ–≤.

### 1. –í—ã–±–æ—Ä —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è

–í –ø–æ–ª–µ ¬´–í—ã–±–µ—Ä–∏—Ç–µ –∏–º–µ–Ω–∞ –∏–∑ –±–∞–∑—ã¬ª –Ω–∞—á–Ω–∏—Ç–µ –≤–≤–æ–¥–∏—Ç—å —Ñ–∞–º–∏–ª–∏—é –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–µ–≥–æ —É—á–µ–Ω–æ–≥–æ –∏ –≤—ã–±–µ—Ä–∏—Ç–µ –µ–≥–æ –∏–∑ —Å–ø–∏—Å–∫–∞. –ú–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–π —Å—Ä–∞–∑—É.

### 2. –û–ø—Ü–∏–∏

**–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ç–∏–ø–∞ –¥–µ—Ä–µ–≤–∞:**
- **–û–±—â–µ–µ –¥–µ—Ä–µ–≤–æ.** –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Å–µ—Ö –∑–∞—â–∏—Ç–∏–≤—à–∏—Ö—Å—è —É—á–µ–Ω–∏–∫–æ–≤.
- **–î–µ—Ä–µ–≤–æ –¥–æ–∫—Ç–æ—Ä–æ–≤ –Ω–∞—É–∫.** –û—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ —Ç–µ—Ö —É—á–µ–Ω–∏–∫–æ–≤, –∫—Ç–æ –∑–∞—â–∏—Ç–∏–ª –¥–æ–∫—Ç–æ—Ä—Å–∫—É—é –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—é (—Ñ–∏–ª—å—Ç—Ä –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ –ø–µ—Ä–≤–æ–º—É —É—Ä–æ–≤–Ω—é).
- **–î–µ—Ä–µ–≤–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –Ω–∞—É–∫.** –û—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –Ω–∞—É–∫.

–ì–∞–ª–æ—á–∫–∞ **¬´–¢–∞–∫–∂–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ (.md)¬ª** —Å–æ–∑–¥–∞—Å—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª —Å–æ —Å–ø–∏—Å–∫–æ–º –∏–µ—Ä–∞—Ä—Ö–∏–∏. –î–∞–Ω–Ω—ã–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ markdown (.md) –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–∞ –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ XMind.

–î–ª—è –∑–∞–ø—É—Å–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É **¬´–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –¥–µ—Ä–µ–≤—å—è¬ª**.

### 3. –†–µ–∑—É–ª—å—Ç–∞—Ç

–ü–æ—Å—Ç—Ä–æ–µ–Ω–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–∞ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö:
- –°—Ç–∞—Ç–∏—á–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞ (PNG) –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –≤ —Å—Ç–∞—Ç—å–∏.
- –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –≥—Ä–∞—Ñ: –º–æ–∂–Ω–æ —É–º–µ–Ω—å—à–∞—Ç—å/—É–≤–µ–ª–∏—á–∏–≤–∞—Ç—å –º–∞—Å—à—Ç–∞–±, –¥–≤–∏–≥–∞—Ç—å —É–∑–ª—ã, —Å–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å/—Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å –≤–µ—Ç–∫–∏ (–Ω–∞–∂–∏–º–∞—è –Ω–∞ –∫–Ω–æ–ø–∫–∏ ‚àí –∏ + –Ω–∞ –≥—Ä–∞—Ñ–µ).
- –î–æ—Å—Ç—É–ø–Ω—ã –∫–Ω–æ–ø–∫–∏ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–∫–∞—Ä—Ç–∏–Ω–∫–∞, HTML-—Ñ–∞–π–ª, —Ç–∞–±–ª–∏—Ü–∞ –¥–∞–Ω–Ω—ã—Ö CSV –∏ XLSX).
- –í–Ω–∏–∑—É –µ—Å—Ç—å –∫–Ω–æ–ø–∫–∞ **¬´üîó –ü–æ–¥–µ–ª–∏—Ç—å—Å—è¬ª**, –∫–æ—Ç–æ—Ä–∞—è –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–µ–∫—É—â–∏–π –≤—ã–±–æ—Ä —É—á–µ–Ω—ã—Ö.
""",
    
    "dissertations": """
## –í–∫–ª–∞–¥–∫–∞ ¬´–ü–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—è—Ö¬ª

–ù–∞ —ç—Ç–æ–π –≤–∫–ª–∞–¥–∫–µ –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ–∏—Å–∫ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π –ø–æ —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º. –ö–æ–¥ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –∫–æ–¥—É –∞–≤—Ç–æ—Ä–µ—Ñ–µ—Ä–∞—Ç–∞ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏ –Ω–∞ —Å–∞–π—Ç–µ –ù–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ ([http://rusneb.ru](http://rusneb.ru)).

### 1. –í—ã–±–æ—Ä –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤ –ø–æ–∏—Å–∫–∞

–í –ø–æ–ª–µ ¬´–í—ã–±–µ—Ä–∏—Ç–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏ –ø–æ–∏—Å–∫–∞¬ª –æ—Ç–º–µ—Ç—å—Ç–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ (–º–∞–∫—Å–∏–º—É–º 5 –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ). –°—Ä–µ–¥–∏ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: –ù–∞–∑–≤–∞–Ω–∏–µ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏, –§–ò–û –∞–≤—Ç–æ—Ä–∞, –§–ò–û –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è, –§–ò–û –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞, –û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –í–µ–¥—É—â–∞—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è, –ú–µ—Å—Ç–æ –∑–∞—â–∏—Ç—ã, –ì–æ—Ä–æ–¥ –∑–∞—â–∏—Ç—ã, –ì–æ–¥ –∑–∞—â–∏—Ç—ã, –°–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å.

### 2. –í–≤–æ–¥ –¥–∞–Ω–Ω—ã—Ö

- –ü–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤ –ø–æ—è–≤—è—Ç—Å—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è –¥–ª—è –≤–≤–æ–¥–∞.
- –î–ª—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –ø–æ–ª–µ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, –§–ò–û –∏–ª–∏ –û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è) –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∞—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è –∏–ª–∏ —Ñ–∞–º–∏–ª–∏–∏ ‚Äì –ø–æ–∏—Å–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ –≤—Ö–æ–∂–¥–µ–Ω–∏—é —Ç–µ–∫—Å—Ç–∞ –±–µ–∑ —É—á–µ—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞.
- –î–ª—è –ø–æ–ª–µ–π ¬´–ì–æ–¥ –∑–∞—â–∏—Ç—ã¬ª, ¬´–ì–æ—Ä–æ–¥¬ª –∏ ¬´–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å¬ª –¥–æ—Å—Ç—É–ø–µ–Ω –≤—ã–±–æ—Ä –∏–∑ –≤—ã–ø–∞–¥–∞—é—â–µ–≥–æ —Å–ø–∏—Å–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π.
- –î–ª—è –∑–∞–ø—É—Å–∫–∞ –ø–æ–∏—Å–∫–∞ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É **¬´–ù–∞–π—Ç–∏¬ª**.

### 3. –†–µ–∑—É–ª—å—Ç–∞—Ç

–°–∏—Å—Ç–µ–º–∞ –≤—ã–≤–µ–¥–µ—Ç —Ç–∞–±–ª–∏—Ü—É —Å–æ —Å–ø–∏—Å–∫–æ–º –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –ø–æ–ª–Ω—ã–µ –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Ä–∞–±–æ—Ç.
- –¢–∞–±–ª–∏—Ü–∞ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–æ–Ω–Ω–æ–º –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–∏, –¥–æ—Å—Ç—É–ø–Ω—É—é –Ω–∞ –ø–µ—Ä–≤—ã—Ö –¥–≤—É—Ö —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ö –∞–≤—Ç–æ—Ä–µ—Ñ–µ—Ä–∞—Ç–∞.
- –ü–æ–ª—É—á–µ–Ω–Ω—É—é –≤—ã–±–æ—Ä–∫—É –º–æ–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ, –Ω–∞–∂–∞–≤ –∫–Ω–æ–ø–∫—É **¬´–°–∫–∞—á–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã¬ª**, –≤—ã–±—Ä–∞–≤ —Ñ–æ—Ä–º–∞—Ç CSV –∏–ª–∏ XLSX.
""",
    
    "profiles": """
## –í–∫–ª–∞–¥–∫–∞ ¬´–ü–æ–∏—Å–∫ –ø–æ —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø—Ä–æ—Ñ–∏–ª—è–º¬ª

–ù–∞ —ç—Ç–æ–π –≤–∫–ª–∞–¥–∫–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π. –û–Ω –æ—Å–Ω–æ–≤–∞–Ω –Ω–µ –Ω–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏ —Å–ª–æ–≤ –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ, –∞ –Ω–∞ –∞–Ω–∞–ª–∏–∑–µ –≤—Å–µ–≥–æ —Ç–µ–∫—Å—Ç–∞ –∞–≤—Ç–æ—Ä–µ—Ñ–µ—Ä–∞—Ç–∞ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–æ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã. –ü–æ–∏—Å–∫ –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç—Å—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∏–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–æ–≥–æ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞, —Å–æ–¥–µ—Ä–∂–∞—â–µ–≥–æ —Ä–∞–∑–ª–∏—á–Ω—ã–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏, –æ—Ç—Ä–∞–∂–∞—é—â–∏–µ –æ–±—ä–µ–∫—Ç, –ø—Ä–æ—Ü–µ—Å—Å –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è.

### 1. –í—ã–±–æ—Ä —Ç–µ–º–∞—Ç–∏–∫–∏

–í –≤—ã–ø–∞–¥–∞—é—â–µ–º —Å–ø–∏—Å–∫–µ ¬´–≠–ª–µ–º–µ–Ω—Ç –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞¬ª –≤—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â—É—é —Ç–µ–º—É, –º–µ—Ç–æ–¥ –∏–ª–∏ –ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫—É—é —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, ¬´–ù–∞—á–∞–ª—å–Ω–æ–µ –æ–±—â–µ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ¬ª, ¬´–ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞¬ª, ¬´–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ —Ü–∏—Ñ—Ä–æ–≤—ã–µ —Ä–µ—Å—É—Ä—Å—ã¬ª, ¬´–ò–Ω–∫–ª—é–∑–∏—è¬ª). –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É **¬´–î–æ–±–∞–≤–∏—Ç—å –≤ –ø–æ–¥–±–æ—Ä–∫—É¬ª**.

### 2. –õ–æ–≥–∏–∫–∞ –ø–æ–∏—Å–∫–∞

- –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≤ –ø–æ–¥–±–æ—Ä–∫—É –æ—Ç –æ–¥–Ω–æ–≥–æ –¥–æ –ø—è—Ç–∏ –ø—É–Ω–∫—Ç–æ–≤ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞.
- –°–∏—Å—Ç–µ–º–∞ –æ—Ç–±–µ—Ä–µ—Ç —Ç–æ–ª—å–∫–æ —Ç–µ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏, —É –∫–æ—Ç–æ—Ä—ã—Ö –æ—Ü–µ–Ω–∫–∞ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è –∫–∞–∂–¥–æ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø—É–Ω–∫—Ç–∞ (—Ç–µ–º—ã) —Å–æ—Å—Ç–∞–≤–ª—è–µ—Ç –Ω–µ –º–µ–Ω–µ–µ 4 –±–∞–ª–ª–æ–≤ (–ø–æ 10-–±–∞–ª–ª—å–Ω–æ–π —à–∫–∞–ª–µ).
- –î–ª—è –∑–∞–ø—É—Å–∫–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É **¬´–ù–∞–π—Ç–∏ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏¬ª**.

### 3. –†–µ–∑—É–ª—å—Ç–∞—Ç

–í—ã –ø–æ–ª—É—á–∏—Ç–µ —Å–ø–∏—Å–æ–∫ —Ä–∞–±–æ—Ç, –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ–ª–Ω–æ —Ä–∞—Å–∫—Ä—ã–≤–∞—é—â–∏—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Ç–µ–º—ã.
- –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞–Ω–∂–∏—Ä—É—é—Ç—Å—è –ø–æ —Å—É–º–º–µ –±–∞–ª–ª–æ–≤: —Å–≤–µ—Ä—Ö—É —Å–ø–∏—Å–∫–∞ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –∏—Å–∫–æ–º—ã–µ —Ç–µ–º—ã –ø—Ä–æ—Ä–∞–±–æ—Ç–∞–Ω—ã –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≥–ª—É–±–æ–∫–æ.
- –î–æ—Å—Ç—É–ø–µ–Ω —Ñ–∏–ª—å—Ç—Ä –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º. –ü–æ–ª–µ **¬´üîç –§–∏–ª—å—Ç—Ä –ø–æ —Ç–∞–±–ª–∏—Ü–µ¬ª** –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–π—Ç–∏ —Ä–∞–±–æ—Ç—É –ø–æ –∞–≤—Ç–æ—Ä—É –∏–ª–∏ —Å–ª–æ–≤—É –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª—É—á–µ–Ω–Ω–æ–π –≤—ã–±–æ—Ä–∫–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤–≤–µ–¥—è ¬´–ú–æ—Å–∫–æ–≤—Å–∫–∏–π –≥–æ—Ä–æ–¥—Å–∫–æ–π –ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–∏–π —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç¬ª, –º–æ–∂–Ω–æ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –ú–ì–ü–£.
- –ò—Ç–æ–≥–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É —Å –±–∞–ª–ª–∞–º–∏ –∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ –º–æ–∂–Ω–æ –≤—ã–≥—Ä—É–∑–∏—Ç—å, –Ω–∞–∂–∞–≤ –∫–Ω–æ–ø–∫—É **¬´–°–∫–∞—á–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã¬ª**. –ß–µ–º –≤—ã—à–µ –±–∞–ª–ª, —Ç–µ–º –≤ –±–æ–ª—å—à–µ–π —Å—Ç–µ–ø–µ–Ω–∏ —Ç–µ–º–∞—Ç–∏–∫–∞ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–º —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –æ—Å—É—â–µ—Å—Ç–≤–ª—è–ª—Å—è –ø–æ–∏—Å–∫.
"""
}

def show_instruction(tab_key: str) -> None:
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –≤–∫–ª–∞–¥–∫–∏ –≤ –º–æ–¥–∞–ª—å–Ω–æ–º –æ–∫–Ω–µ."""
    @st.dialog("üìñ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è", width="large")
    def _show_dialog():
        st.markdown(INSTRUCTIONS.get(tab_key, "–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."))
    
    _show_dialog()

def download_data_dialog(df: pd.DataFrame, file_base: str, key_prefix: str) -> None:
    """
    –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è (XLSX –∏–ª–∏ CSV).
    XLSX –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–º –∏ –≤—ã–¥–µ–ª–µ–Ω –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç.
    """
    @st.dialog(f"–°–∫–∞—á–∞—Ç—å –¥–∞–Ω–Ω—ã–µ: {file_base}")
    def _show_dialog():
        st.write("–í—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç:")
        
        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ Excel
        try:
            buf_xlsx = io.BytesIO()
            with pd.ExcelWriter(buf_xlsx, engine="openpyxl") as writer:
                df.to_excel(writer, index=False)
            data_xlsx = buf_xlsx.getvalue()
            
            st.download_button(
                label="üìä –°–∫–∞—á–∞—Ç—å Excel (.xlsx)",
                data=data_xlsx,
                file_name=f"{file_base}.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                key=f"{key_prefix}_dl_xlsx",
                type="primary",  # –î–µ–ª–∞–µ–º –∫–Ω–æ–ø–∫—É –∞–∫—Ü–µ–Ω—Ç–Ω–æ–π
                use_container_width=True
            )
        except ImportError:
            st.error("–î–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤ Excel —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –±–∏–±–ª–∏–æ—Ç–µ–∫—É openpyxl.")
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è Excel: {e}")

        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ CSV
        data_csv = df.to_csv(index=False, encoding="utf-8-sig").encode("utf-8-sig")
        st.download_button(
            label="üìÑ –°–∫–∞—á–∞—Ç—å CSV (.csv)",
            data=data_csv,
            file_name=f"{file_base}.csv",
            mime="text/csv",
            key=f"{key_prefix}_dl_csv",
            use_container_width=True
        )
    
    _show_dialog()
    
# ---------------------- –û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã -------------------------------
st.set_page_config(page_title="–ê–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏–µ —Ä–æ–¥–æ—Å–ª–æ–≤–Ω—ã–µ", layout="wide")

# –ü–æ–ª–Ω–æ—à–∏—Ä–∏–Ω–Ω—ã–π (full-bleed) –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
st.markdown("""
<style>
  iframe {
        width: 100%;
  }
</style>
""", unsafe_allow_html=True)


def _default_feedback_state() -> Dict[str, str]:
    return {"name": "", "email": "", "message": ""}


def _get_feedback_state() -> Dict[str, str]:
    state = st.session_state.get(FEEDBACK_FORM_STATE_KEY)
    if isinstance(state, dict):
        return state
    state = _default_feedback_state()
    st.session_state[FEEDBACK_FORM_STATE_KEY] = state
    return state


def _store_feedback(name: str, email: str, message: str) -> None:
    FEEDBACK_FILE.parent.mkdir(parents=True, exist_ok=True)
    record = [
        datetime.utcnow().isoformat(timespec="seconds") + "Z",
        name.strip(),
        email.strip(),
        message.replace("\r\n", "\n").replace("\r", "\n"),
    ]
    file_exists = FEEDBACK_FILE.exists()
    with FEEDBACK_FILE.open("a", newline="", encoding="utf-8") as fp:
        writer = csv.writer(fp)
        if not file_exists:
            writer.writerow(["timestamp", "name", "email", "message"])
        writer.writerow(record)


def _trigger_rerun() -> None:
    try:  # Streamlit >= 1.32
        st.rerun()
    except AttributeError:  # pragma: no cover - —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ Streamlit
        st.experimental_rerun()  # type: ignore[attr-defined]


def feedback_button() -> None:
    @st.dialog("–û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å")
    def _show_feedback_dialog() -> None:
        st.write("–ë—É–¥–µ–º —Ä–∞–¥—ã –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è–º –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—à–∏–±–∫–∞—Ö.")

        feedback_state = _get_feedback_state()
        pending_message = st.session_state.pop(FEEDBACK_FORM_RESULT_KEY, None)
        if pending_message:
            status, context = pending_message
            if status == "success":
                st.success(
                    f"–°–ø–∞—Å–∏–±–æ, {context or '–∫–æ–ª–ª–µ–≥–∞'}! –ú—ã –ø–æ–ª—É—á–∏–ª–∏ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."
                )
            elif status == "warning":
                st.warning("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–ª–µ ¬´–°–æ–æ–±—â–µ–Ω–∏–µ¬ª.")

        with st.form(key="feedback_form"):
            name = st.text_input("–ò–º—è", value=feedback_state.get("name", ""))
            email = st.text_input("E-mail", value=feedback_state.get("email", ""))
            message = st.text_area(
                "–°–æ–æ–±—â–µ–Ω–∏–µ", value=feedback_state.get("message", ""), height=180
            )
            submitted = st.form_submit_button("–û—Ç–ø—Ä–∞–≤–∏—Ç—å")

        if submitted:
            feedback_state = {
                "name": name,
                "email": email,
                "message": message,
            }
            if message.strip():
                _store_feedback(name, email, message)
                st.session_state[FEEDBACK_FORM_RESULT_KEY] = ("success", name)
                st.session_state[FEEDBACK_FORM_STATE_KEY] = _default_feedback_state()
            else:
                st.session_state[FEEDBACK_FORM_RESULT_KEY] = ("warning", None)
                st.session_state[FEEDBACK_FORM_STATE_KEY] = feedback_state
            _trigger_rerun()

    if st.button("–û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å", key="feedback_button", use_container_width=True):
        _show_feedback_dialog()


header_left, header_right = st.columns([0.78, 0.22])
with header_left:
    st.title("üìö –ê–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ–∞–ª–æ–≥–∏—è")
    st.caption(
        "–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–µ—Ä–µ–≤—å–µ–≤ –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–∞, –ø–æ–∏—Å–∫–∞ –∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π –ø–æ —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω—ã–º –∏ —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º. –í –Ω–∞—Å—Ç–æ—è—â–∏–π –º–æ–º–µ–Ω—Ç –æ—Å–Ω–æ–≤—É –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Å–æ—Å—Ç–∞–≤–ª—è—é—Ç –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–æ–Ω–Ω—ã–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –ø–æ –ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–∏–º –Ω–∞—É–∫–∞–º —Å 1995 –ø–æ 2024 –≥–æ–¥."
    )
with header_right:
    feedback_button()

# ---------------------- –•–µ–ª–ø–µ—Ä—ã -------------------------------------------

def _norm(s: str) -> str:
    return re.sub(r"\s+", " ", s.replace(".", " ").strip().lower())


def _split(full: str) -> Tuple[str, str, str]:
    p = full.split()
    p += ["", "", ""]
    return (p[0], p[1] if len(p) > 1 else "", p[2] if len(p) > 2 else "")


def variants(full: str) -> Set[str]:
    last, first, mid = _split(full.strip())
    fi, mi = first[:1], mid[:1]
    init = fi + mi
    init_dots = ".".join(init) + "." if init else ""
    return {
        v.strip()
        for v in {
            full,
            f"{last} {first} {mid}".strip(),
            f"{last} {init}",
            f"{last} {init_dots}",
            f"{init} {last}",
            f"{init_dots} {last}",
        }
        if v
    }


def degree_level(row: pd.Series) -> str:
    raw = str(row.get("degree.degree_level", ""))
    value = raw.strip().lower()
    if value.startswith("–¥–æ–∫"):
        return "doctor"
    if value.startswith("–∫–∞–Ω"):
        return "candidate"
    return ""


def is_doctor(row: pd.Series) -> bool:
    return degree_level(row) == "doctor"


def is_candidate(row: pd.Series) -> bool:
    return degree_level(row) == "candidate"


TREE_OPTIONS: List[tuple[str, str, Callable[[pd.Series], bool] | None]] = [
    ("–û–±—â–µ–µ –¥–µ—Ä–µ–≤–æ", "general", None),
    ("–î–µ—Ä–µ–≤–æ –¥–æ–∫—Ç–æ—Ä–æ–≤ –Ω–∞—É–∫", "doctors", is_doctor),
    ("–î–µ—Ä–µ–≤–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –Ω–∞—É–∫", "candidates", is_candidate),
]


def build_index(df: pd.DataFrame, supervisor_cols: List[str]) -> Dict[str, Set[int]]:
    idx: Dict[str, Set[int]] = {}
    for col in supervisor_cols:
        if col not in df.columns:
            continue
        for i, raw in df[col].dropna().items():
            for v in variants(str(raw)):
                idx.setdefault(_norm(v), set()).add(i)
    return idx


def rows_for(df: pd.DataFrame, index: Dict[str, Set[int]], name: str) -> pd.DataFrame:
    hits: Set[int] = set()
    for v in variants(name):
        hits.update(index.get(_norm(v), set()))
    return df.loc[list(hits)] if hits else df.iloc[0:0]


def lineage(
    df: pd.DataFrame,
    index: Dict[str, Set[int]],
    root: str,
    first_level_filter: Callable[[pd.Series], bool] | None = None,
) -> tuple[nx.DiGraph, pd.DataFrame]:
    G = nx.DiGraph()
    selected_indices: Set[int] = set()
    Q, seen = [root], set()
    while Q:
        cur = Q.pop(0)
        if cur in seen:
            continue
        seen.add(cur)
        rows = rows_for(df, index, cur)
        for idx, r in rows.iterrows():
            child = str(r.get(AUTHOR_COLUMN, "")).strip()
            if child:
                if cur == root and first_level_filter is not None:
                    if not first_level_filter(r):
                        continue
                G.add_edge(cur, child)
                Q.append(child)
                selected_indices.add(idx)
    subset = df.loc[sorted(selected_indices)] if selected_indices else df.iloc[0:0]
    return G, subset


def multiline(name: str) -> str:
    return "\n".join(str(name).split())


def slug(s: str) -> str:
    return re.sub(r"[^A-Za-z–ê-–Ø–∞-—è0-9]+", "_", s).strip("_")


def _clean_path(*parts: str) -> str:
    cleaned = "/".join(p.strip("/") for p in parts if p and p.strip("/"))
    return f"/{cleaned}" if cleaned else ""


def _configured_base_url() -> str | None:
    if PUBLIC_APP_URL:
        return PUBLIC_APP_URL
    keys = ("public_base_url", "base_url", "BASE_URL")
    for key in keys:
        try:
            val = st.secrets.get(key)  # type: ignore[attr-defined]
        except Exception:
            val = None
        if val:
            return str(val).rstrip("/")
    for key in ("PUBLIC_BASE_URL", "BASE_URL"):
        val = os.environ.get(key)
        if val:
            return val.rstrip("/")
    return None


def _base_url_from_headers() -> str | None:
    if get_script_run_ctx is None:
        return None
    try:
        ctx = get_script_run_ctx()
    except Exception:
        ctx = None
    if not ctx:
        return None
    headers = getattr(ctx, "request_headers", None)
    if not headers:
        return None
    lowered = {str(k).lower(): str(v) for k, v in headers.items() if v}
    prefix = lowered.get("x-forwarded-prefix", "")
    base_path = st.get_option("server.baseUrlPath") or ""

    host = lowered.get("x-forwarded-host") or lowered.get("host")
    if host:
        proto = lowered.get("x-forwarded-proto")
        if proto:
            proto = proto.split(",")[0].strip()
        else:
            forwarded_port = lowered.get("x-forwarded-port")
            proto = "https" if forwarded_port == "443" or host.endswith(":443") else "http"
        path = _clean_path(prefix, base_path)
        return f"{proto}://{host}{path}".rstrip("/")

    referer = lowered.get("referer") or lowered.get("origin")
    if not referer:
        return None
    parsed = urlsplit(referer)
    if not parsed.scheme or not parsed.netloc:
        return None
    path = _clean_path(prefix or parsed.path, base_path)
    base = f"{parsed.scheme}://{parsed.netloc}"
    return f"{base}{path}".rstrip("/")


def _base_url_from_options() -> str | None:
    try:
        addr = st.get_option("browser.serverAddress")
        port = st.get_option("browser.serverPort")
    except Exception:
        return None
    if not addr:
        return None
    base_path = st.get_option("server.baseUrlPath") or ""
    proto = "https" if str(port) == "443" else "http"
    if (proto == "https" and str(port) in ("", "443")) or (proto == "http" and str(port) in ("", "80")):
        host = addr
    else:
        host = f"{addr}:{port}"
    path = _clean_path(base_path)
    return f"{proto}://{host}{path}".rstrip("/")


def build_share_url(names: List[str]) -> str:
    params = urlencode([("root", n) for n in names])
    query = f"?{params}" if params else ""
    base_url = _configured_base_url() or _base_url_from_headers() or _base_url_from_options()
    return f"{base_url}{query}" if base_url else query


def share_button(names: List[str], key: str) -> None:
    @st.dialog("–°—Å—ã–ª–∫–∞ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞")
    def _show_dialog(url: str) -> None:
        st.text_input("URL", url, key=f"share_url_{key}")

    if st.button("üîó –ü–æ–¥–µ–ª–∏—Ç—å—Å—è", key=key):
        try:
            st.query_params.clear()
            st.query_params["root"] = names
        except Exception:
            try:
                st.experimental_set_query_params(root=names)
            except Exception:
                pass
        url = build_share_url(names)
        _show_dialog(url)


# --------- –†–∏—Å–æ–≤–∞–Ω–∏–µ PNG (—É–º–µ–Ω—å—à–∞–µ–º —à—Ä–∏—Ñ—Ç—ã –∏ —É–∑–ª—ã) -----------------------

def _hierarchy_pos(G: nx.DiGraph, root: str):
    from collections import deque
    levels: Dict[int, List[str]] = {}
    q = deque([(root, 0)])
    seen = set()
    while q:
        n, d = q.popleft()
        if n in seen:
            continue
        seen.add(n)
        levels.setdefault(d, []).append(n)
        for c in G.successors(n):
            q.append((c, d + 1))
    pos: Dict[str, tuple[float, float]] = {}
    for depth, nodes in levels.items():
        width = len(nodes)
        for i, n in enumerate(nodes):
            x = (i + 1) / (width + 1)
            y = -depth
            pos[n] = (x, y)
    return pos


def draw_matplotlib(G: nx.DiGraph, root: str) -> plt.Figure:
    if G.number_of_nodes() == 0:
        fig = plt.figure(figsize=(6, 3.5))
        plt.axis("off")
        plt.text(0.5, 0.5, "–ü–æ—Ç–æ–º–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", ha="center", va="center")
        return fig
    try:
        import networkx.drawing.nx_pydot as nx_pydot  # type: ignore
        pos = nx_pydot.graphviz_layout(G, prog="dot")
    except Exception:
        pos = _hierarchy_pos(G, root)
    fig = plt.figure(figsize=(max(6, len(G) * 0.45), 6))
    nx.draw(
        G,
        pos,
        with_labels=True,
        labels={n: multiline(n) for n in G.nodes},
        node_color="#ADD8E6",
        node_size=2000,   # –±—ã–ª–æ 3200 ‚Üí –Ω–µ–º–Ω–æ–≥–æ –º–µ–Ω—å—à–µ
        font_size=7,      # –∑–∞–º–µ—Ç–Ω–æ –º–µ–Ω—å—à–µ —à—Ä–∏—Ñ—Ç
        arrows=True,
    )
    plt.title(f"–ê–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∞—è —Ä–æ–¥–æ—Å–ª–æ–≤–Ω–∞—è ‚Äì {root}", fontsize=10)
    plt.tight_layout()
    return fig


# --------- –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è HTML-–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è (—É–º–µ–Ω—å—à–∞–µ–º —à—Ä–∏—Ñ—Ç—ã) -----------

def build_pyvis_html(G: nx.DiGraph, root: str) -> str:
    net = Network(height="1000px", width="100%", directed=True, bgcolor="#ffffff")
    net.toggle_physics(True)

    children_map: Dict[str, List[str]] = {}
    nodes_payload: List[str] = []
    for n in G.nodes:
        node_id = str(n)
        nodes_payload.append(node_id)
        successors = [str(child) for child in G.successors(n)]
        if successors:
            children_map[node_id] = successors
        net.add_node(
            node_id,
            label=multiline(n),
            title=str(n),
            shape="box",
            color="#ADD8E6",
        )

    edges_payload: List[Dict[str, str]] = []
    for u, v in G.edges:
        src = str(u)
        dst = str(v)
        edges_payload.append({"from": src, "to": dst})
        net.add_edge(src, dst, arrows="to")

    vis_opts = {
        "nodes": {"font": {"size": 12}},  # —à—Ä–∏—Ñ—Ç –ø–æ–º–µ–Ω—å—à–µ
        "layout": {"hierarchical": {"direction": "UD", "sortMethod": "directed"}},
        "interaction": {"hover": True},
        "physics": {
            "hierarchicalRepulsion": {
                "nodeDistance": 140,
                "springLength": 160,
                "springConstant": 0.01,
            },
            "solver": "hierarchicalRepulsion",
            "stabilization": {"iterations": 200},
            "minVelocity": 0.1,
        },
    }
    net.set_options(json.dumps(vis_opts))

    try:
        html = net.generate_html()  # type: ignore[attr-defined]
    except Exception:
        tmp = Path("_tmp.html")
        net.save_graph(str(tmp))
        html = tmp.read_text(encoding="utf-8")
        try:
            tmp.unlink()
        except Exception:
            pass

    config = {
        "root": str(root),
        "childrenMap": children_map,
        "nodes": nodes_payload,
        "edges": edges_payload,
    }
    config_json = json.dumps(config, ensure_ascii=False)

    injection = textwrap.dedent(
        """
        <style>
          #mynetwork .branch-toggle-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
          }

          #mynetwork .branch-toggle {
            position: absolute;
            transform: translate(-50%, 0);
            border-radius: 50%;
            border: 1px solid #2d3f5f;
            background: #ffffff;
            color: #2d3f5f;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            user-select: none;
            padding: 0;
            min-width: 16px;
            min-height: 16px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            transition: background-color 0.2s ease, color 0.2s ease;
            z-index: 10;
          }

          #mynetwork .branch-toggle:hover {
            background: #2d3f5f;
            color: #ffffff;
          }
        </style>
        <script>
        (function() {
          const config = __CONFIG_JSON__;
          const network = window.network;
          if (!network || !network.body || !network.body.data) {
            return;
          }
          const container = document.getElementById("mynetwork");
          if (!container) {
            return;
          }

          const childrenMap = config.childrenMap || {};
          const rootId = config.root;
          const originalNodes = Array.isArray(config.nodes) ? config.nodes : [];
          const originalEdges = Array.isArray(config.edges) ? config.edges : [];
          const originalNodeSet = new Set(originalNodes);
          const originalEdgeSet = new Set(
            originalEdges.map(function(edge) {
              return edge.from + "\u2192" + edge.to;
            })
          );

          const toggleLayer = document.createElement("div");
          toggleLayer.className = "branch-toggle-layer";
          container.appendChild(toggleLayer);

          const toggles = new Map();
          const collapsed = {};
          const descendantCache = {};

          function getDescendants(nodeId) {
            if (descendantCache[nodeId]) {
              return descendantCache[nodeId];
            }
            const result = [];
            const queue = (childrenMap[nodeId] || []).slice();
            const seen = new Set();
            while (queue.length) {
              const current = queue.shift();
              if (seen.has(current)) {
                continue;
              }
              seen.add(current);
              result.push(current);
              const children = childrenMap[current];
              if (children && children.length) {
                queue.push.apply(queue, children);
              }
            }
            descendantCache[nodeId] = result;
            return result;
          }

          function updateButton(nodeId) {
            const button = toggles.get(nodeId);
            if (!button) {
              return;
            }
            button.textContent = collapsed[nodeId] ? "+" : "\u2212";
            const node = network.body.data.nodes.get(nodeId);
            if (node && node.hidden) {
              button.style.display = "none";
            } else {
              button.style.display = "flex";
            }
          }

          function setNodesHidden(ids, hidden) {
            if (!ids.length) {
              return;
            }
            const updates = [];
            ids.forEach(function(id) {
              if (!originalNodeSet.has(id)) {
                return;
              }
              updates.push({ id: id, hidden: hidden });
            });
            if (updates.length) {
              network.body.data.nodes.update(updates);
            }
          }

          function setEdgesHidden(idSet, hidden) {
            if (!idSet.size) {
              return;
            }
            const updates = [];
            network.body.data.edges.forEach(function(edge) {
              const key = edge.from + "\u2192" + edge.to;
              if (!originalEdgeSet.has(key)) {
                return;
              }
              if (idSet.has(edge.from) || idSet.has(edge.to)) {
                updates.push({ id: edge.id, hidden: hidden });
              }
            });
            if (updates.length) {
              network.body.data.edges.update(updates);
            }
          }

          function hideBranch(nodeId) {
            if (!childrenMap[nodeId] || !childrenMap[nodeId].length) {
              return;
            }
            collapsed[nodeId] = true;
            const descendants = getDescendants(nodeId);
            const idSet = new Set(descendants);
            setNodesHidden(descendants, true);
            setEdgesHidden(idSet, true);
            descendants.forEach(function(id) {
              const button = toggles.get(id);
              if (button) {
                button.style.display = "none";
              }
            });
            updateButton(nodeId);
            window.requestAnimationFrame(updatePositions);
          }

          function showBranch(nodeId) {
            if (!childrenMap[nodeId] || !childrenMap[nodeId].length) {
              return;
            }
            collapsed[nodeId] = false;
            const descendants = getDescendants(nodeId);
            const idSet = new Set(descendants);
            setNodesHidden(descendants, false);
            setEdgesHidden(idSet, false);
            updateButton(nodeId);
            descendants.forEach(function(id) {
              updateButton(id);
            });
            descendants.forEach(function(id) {
              if (collapsed[id]) {
                hideBranch(id);
                const button = toggles.get(id);
                if (button) {
                  button.style.display = "flex";
                }
              }
            });
            if (descendants.length > 8) {
              network.stabilize();
            }
            window.requestAnimationFrame(updatePositions);
          }

          function toggleBranch(nodeId) {
            if (collapsed[nodeId]) {
              showBranch(nodeId);
            } else {
              hideBranch(nodeId);
            }
          }

          function updatePositions() {
            toggles.forEach(function(button, nodeId) {
              const node = network.body.data.nodes.get(nodeId);
              if (!node || node.hidden) {
                return;
              }
              const bounding = network.getBoundingBox(nodeId);
              if (!bounding) {
                return;
              }

              const bottomCenterCanvas = {
                x: (bounding.left + bounding.right) / 2,
                y: bounding.bottom,
              };
              const topLeftDom = network.canvasToDOM({
                x: bounding.left,
                y: bounding.top,
              });
              const bottomRightDom = network.canvasToDOM({
                x: bounding.right,
                y: bounding.bottom,
              });
              const bottomCenterDom = network.canvasToDOM(bottomCenterCanvas);

              const width = bottomRightDom.x - topLeftDom.x;
              const height = bottomRightDom.y - topLeftDom.y;
              let verticalOffset = 14;

              if (Number.isFinite(width) && Number.isFinite(height)) {
                const minDimension = Math.max(0, Math.min(width, height));
                const size = Math.max(16, Math.min(36, minDimension * 0.5));
                const roundedSize = Math.round(size);
                const fontSize = Math.max(9, Math.round(size * 0.45));
                button.style.width = roundedSize + "px";
                button.style.height = roundedSize + "px";
                button.style.fontSize = fontSize + "px";
                verticalOffset = Math.max(10, Math.round(roundedSize / 2 + 6));
              }

              button.style.left = bottomCenterDom.x + "px";
              button.style.top = bottomCenterDom.y + verticalOffset + "px";
            });
          }

          Object.keys(childrenMap).forEach(function(nodeId) {
            if (nodeId === rootId) {
              collapsed[nodeId] = false;
              return;
            }
            if (!childrenMap[nodeId] || !childrenMap[nodeId].length) {
              collapsed[nodeId] = false;
              return;
            }
            const button = document.createElement("button");
            button.type = "button";
            button.className = "branch-toggle";
            button.style.width = "20px";
            button.style.height = "20px";
            button.style.fontSize = "12px";
            button.textContent = "\u2212";
            button.title = "–°–≤–µ—Ä–Ω—É—Ç—å/—Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å –≤–µ—Ç–∫—É";
            button.addEventListener("click", function(evt) {
              evt.preventDefault();
              evt.stopPropagation();
              toggleBranch(nodeId);
            });
            toggleLayer.appendChild(button);
            toggles.set(nodeId, button);
            collapsed[nodeId] = false;
            updateButton(nodeId);
          });

          if (!toggles.size) {
            return;
          }

          network.on("afterDrawing", updatePositions);
          network.once("stabilizationIterationsDone", function() {
            window.requestAnimationFrame(updatePositions);
          });
          window.addEventListener("resize", updatePositions);
          updatePositions();
        })();
        </script>
        """
    ).replace("__CONFIG_JSON__", config_json)

    if "</body>" in html:
        html = html.replace("</body>", f"{injection}\n</body>")
    else:
        html += injection

    return html


# ---------------------- –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö ----------------------------------
@st.cache_data(show_spinner=False)
def load_data() -> pd.DataFrame:
    base = Path(DATA_DIR).expanduser().resolve()
    files = sorted(base.glob(CSV_GLOB))
    if not files:
        raise FileNotFoundError(f"–í {base} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ CSV –ø–æ –º–∞—Å–∫–µ '{CSV_GLOB}'")

    # –ø—Ä–æ—Å—Ç–∞—è –∞–≤—Ç–æ‚Äë–¥–µ—Ç–µ–∫—Ü–∏—è —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è –ø–æ –ø–µ—Ä–≤–æ–º—É —Ñ–∞–π–ª—É
    try:
        sample = pd.read_csv(files[0], nrows=5, dtype=str)
        sep = ";" if sample.shape[1] == 1 else ","
    except Exception:
        sep = ","

    frames = [pd.read_csv(f, dtype=str, keep_default_na=False, sep=sep) for f in files]
    return pd.concat(frames, ignore_index=True)


@st.cache_data(show_spinner=False)
def load_basic_scores() -> pd.DataFrame:
    base = Path(BASIC_SCORES_DIR).expanduser().resolve()
    files = sorted(base.glob("*.csv"))
    if not files:
        raise FileNotFoundError(
            f"–í {base} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ CSV —Å —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–æ—Ñ–∏–ª—è–º–∏"
        )

    frames: list[pd.DataFrame] = []
    for file in files:
        frame = pd.read_csv(file)
        if "Code" not in frame.columns:
            raise KeyError(f"–í —Ñ–∞–π–ª–µ {file.name} –Ω–µ—Ç —Å—Ç–æ–ª–±—Ü–∞ 'Code'")
        frames.append(frame)

    scores = pd.concat(frames, ignore_index=True)
    scores = scores.dropna(subset=["Code"])
    scores["Code"] = scores["Code"].astype(str).str.strip()
    scores = scores[scores["Code"].str.len() > 0]
    scores = scores.drop_duplicates(subset="Code", keep="first")

    feature_columns = [c for c in scores.columns if c != "Code"]
    if not feature_columns:
        raise ValueError("–ù–µ –Ω–∞–π–¥–µ–Ω—ã —Å—Ç–æ–ª–±—Ü—ã —Å —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏")

    scores[feature_columns] = scores[feature_columns].apply(
        pd.to_numeric, errors="coerce"
    )
    scores[feature_columns] = scores[feature_columns].fillna(0.0)

    return scores


ComparisonScope = Literal["direct", "all"]


def gather_school_dataset(
    df: pd.DataFrame,
    index: Dict[str, Set[int]],
    root: str,
    scores: pd.DataFrame,
    scope: ComparisonScope = "direct",
) -> tuple[pd.DataFrame, pd.DataFrame, int]:
    if scope == "direct":
        subset = rows_for(df, index, root)
    elif scope == "all":
        _, subset = lineage(df, index, root)
    else:  # pragma: no cover - –∑–∞—â–∏—Ç–Ω–∞—è –≤–µ—Ç–∫–∞
        raise ValueError(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º —Å—Ä–∞–≤–Ω–µ–Ω–∏—è: {scope}")
    if subset.empty:
        empty = pd.DataFrame(columns=[*scores.columns, "school", AUTHOR_COLUMN])
        return empty, empty, 0

    working = subset[["Code", AUTHOR_COLUMN]].copy()
    working["Code"] = working["Code"].astype(str).str.strip()
    working = working[working["Code"].str.len() > 0]
    codes = working["Code"].unique().tolist()

    dataset = scores[scores["Code"].isin(codes)].copy()
    dataset["school"] = root
    dataset = dataset.merge(
        working.drop_duplicates(subset="Code"), on="Code", how="left"
    )

    missing_codes = sorted(set(codes) - set(dataset["Code"]))
    missing_info = (
        working[working["Code"].isin(missing_codes)]
        .drop_duplicates(subset="Code")
        .rename(columns={AUTHOR_COLUMN: "candidate_name"})
    )

    dataset = dataset.rename(columns={AUTHOR_COLUMN: "candidate_name"})
    if "candidate_name" not in dataset.columns:
        dataset["candidate_name"] = None

    return dataset, missing_info, len(codes)


SILHOUETTE_HELP_TEXT = """
–°–∏–ª—É—ç—Ç–Ω—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É—é—Ç, –Ω–∞—Å–∫–æ–ª—å–∫–æ —Ö–æ—Ä–æ—à–æ —Ä–∞–∑–¥–µ–ª–µ–Ω—ã –∫–ª–∞—Å—Ç–µ—Ä—ã –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ: –Ω–∞—Å–∫–æ–ª—å–∫–æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏ –æ–¥–Ω–æ–π –Ω–∞—É—á–Ω–æ–π —à–∫–æ–ª—ã —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏ —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω–æ –±–ª–∏–∑–∫–∏ –∫ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—è –¥—Ä—É–≥–æ–π –Ω–∞—É—á–Ω–æ–π —à–∫–æ–ª—ã.

–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –æ—Å—å ‚Äì —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ —Å–∏–ª—É—ç—Ç–∞.

–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –æ—Å—å ‚Äì –æ—Ç–¥–µ–ª—å–Ω—ã–µ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏, —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ –∫–ª–∞—Å—Ç–µ—Ä–∞–º (–Ω–∞—É—á–Ω—ã–º —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º). ¬´–õ–µ–∑–≤–∏–µ¬ª –≥—Ä–∞—Ñ–∏–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –æ–¥–∏–Ω –∫–ª–∞—Å—Ç–µ—Ä.

–®–∏—Ä–∏–Ω–∞ ¬´–ª–µ–∑–≤–∏—è¬ª –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–±–æ—Ç –≤ –∫–ª–∞—Å—Ç–µ—Ä–µ.

–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –ø—É–Ω–∫—Ç–∏—Ä–Ω–∞—è –ª–∏–Ω–∏—è ‚Äì —ç—Ç–æ —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ —Å–∏–ª—É—ç—Ç–∞ –¥–ª—è –≤—Å–µ—Ö —Ä–∞–±–æ—Ç. –≠—Ç–æ –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –æ—Ü–µ–Ω–∏–≤–∞–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏, —Ç–æ –µ—Å—Ç—å –Ω–∞—Å–∫–æ–ª—å–∫–æ —Ö–æ—Ä–æ—à–æ —Ä–∞–±–æ—Ç—ã —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω—ã. –ó–Ω–∞—á–µ–Ω–∏–µ –≤–∞—Ä—å–∏—Ä—É–µ—Ç—Å—è –æ—Ç -1 –¥–æ +1.
- –ó–Ω–∞—á–µ–Ω–∏–µ, –±–ª–∏–∑–∫–æ–µ –∫ +1 —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ, —á—Ç–æ –∫–ª–∞—Å—Ç–µ—Ä—ã –ø–ª–æ—Ç–Ω—ã–µ, —á–µ—Ç–∫–æ —Ä–∞–∑–¥–µ–ª–µ–Ω—ã, –∏ —Ä–∞–±–æ—Ç—ã –≤–Ω—É—Ç—Ä–∏ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã –æ—á–µ–Ω—å –ø–æ—Ö–æ–∂–∏ –¥—Ä—É–≥ –Ω–∞ –¥—Ä—É–≥–∞, –Ω–æ —Å–∏–ª—å–Ω–æ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –æ—Ç —Ä–∞–±–æ—Ç –≤ –¥—Ä—É–≥–∏—Ö –≥—Ä—É–ø–ø–∞—Ö. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ: –º–µ–∂–¥—É –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—è–º–∏ –¥–≤—É—Ö –Ω–∞—É—á–Ω—ã—Ö —à–∫–æ–ª –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –∏ —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è.
- –ó–Ω–∞—á–µ–Ω–∏–µ, –±–ª–∏–∑–∫–æ–µ –∫ 0, –≥–æ–≤–æ—Ä–∏—Ç –æ —Ç–æ–º, —á—Ç–æ –∫–ª–∞—Å—Ç–µ—Ä—ã —Å–∏–ª—å–Ω–æ –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è, –∏ —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã –º–µ–∂–¥—É –Ω–∏–º–∏ —Ä–∞–∑–º—ã—Ç—ã.
- –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (–±–ª–∏–∑–∫–æ–µ –∫ -1) —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ, —á—Ç–æ —Ä–∞–±–æ—Ç—ã, –≤–µ—Ä–æ—è—Ç–Ω–æ, –±—ã–ª–∏ –æ—Ç–Ω–µ—Å–µ–Ω—ã –∫ –Ω–µ–≤–µ—Ä–Ω–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É. –≠—Ç–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –æ—á–µ–Ω—å –≤—ã—Å–æ–∫—É—é —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫—É—é –±–ª–∏–∑–æ—Å—Ç—å –∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —á–µ—Ç–∫–æ–≥–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è.  –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ: –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏ –¥–≤—É—Ö –Ω–∞—É—á–Ω—ã—Ö —à–∫–æ–ª —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏ —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω–æ –æ—á–µ–Ω—å –ª–∏–∑–∫–∏ –¥—Ä—É–≥ –∫ –¥—Ä—É–≥—É.

–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏, –æ–±—Ä–∞–∑—É—é—â–∏–µ ¬´–ª–µ–∑–≤–∏–µ¬ª ‚Äì —ç—Ç–æ —ç–ª–µ–º–µ–Ω—Ç—ã –∫–ª–∞—Å—Ç–µ—Ä–∞. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ –æ–¥–Ω–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –ª–∏–Ω–∞ = –æ–¥–Ω–∞ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—è.

–î–ª–∏–Ω–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π –ª–∏–Ω–∏–∏ = —Å—Ç–µ–ø–µ–Ω—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è:
- –î–ª–∏–Ω–Ω–∞—è –ª–∏–Ω–∏—è –≤–ø—Ä–∞–≤–æ (–∑–Ω–∞—á–µ–Ω–∏–µ –±–ª–∏–∑–∫–æ –∫ +1) –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—è ‚Äì –æ–±—Ä–∞–∑—Ü–æ–≤—ã–π –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—å —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã. –ï–µ —Ç–µ–º–∞ –æ—á–µ–Ω—å –±–ª–∏–∑–∫–∞ –∫ –¥—Ä—É–≥–∏–º —Ä–∞–±–æ—Ç–∞–º –≤ —ç—Ç–æ–π –∂–µ —à–∫–æ–ª–µ –∏ —Å–∏–ª—å–Ω–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Ç–µ–º –≤ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º–æ–π —à–∫–æ–ª–µ. –û–Ω–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ ¬´—è–¥—Ä–µ¬ª –∫–ª–∞—Å—Ç–µ—Ä–∞.
- –ö–æ—Ä–æ—Ç–∫–∞—è –ª–∏–Ω–∏—è (–∑–Ω–∞—á–µ–Ω–∏–µ –±–ª–∏–∑–∫–æ –∫ 0) –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—è –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ ¬´–≥—Ä–∞–Ω–∏—Ü–µ¬ª. –ï–µ —Ç–µ–º–∞ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∞ –Ω–∞ —Å—Ç—ã–∫–µ –¥–≤—É—Ö –Ω–∞—É—á–Ω—ã—Ö —à–∫–æ–ª. –û–Ω–∞ –æ–¥–∏–Ω–∞–∫–æ–≤–æ (–Ω–µ)–ø–æ—Ö–æ–∂–∞ –∫–∞–∫ –Ω–∞ —Å–≤–æ–∏—Ö, —Ç–∞–∫ –∏ –Ω–∞ —á—É–∂–∏—Ö.
- –õ–∏–Ω–∏—è, —É—Ö–æ–¥—è—â–∞—è –≤–ª–µ–≤–æ –≤ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—É—é –∑–æ–Ω—É (–∑–Ω–∞—á–µ–Ω–∏–µ < 0) –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —ç—Ç–æ ¬´–∞–Ω–æ–º–∞–ª–∏—è¬ª –∏–ª–∏ –ø—Ä–∏–∑–Ω–∞–∫ —Å–∏–ª—å–Ω–æ–≥–æ —Å–º–µ—à–µ–Ω–∏—è. –≠—Ç–∞ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—è, —Ö–æ—Ç—è —Ñ–æ—Ä–º–∞–ª—å–Ω–æ –∏ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –∫ —Å–≤–æ–µ–π –≥—Ä—É–ø–ø–µ, –ø–æ —Å–≤–æ–µ–º—É —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é (—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–º—É –ø—Ä–æ—Ñ–∏–ª—é) –æ–∫–∞–∑–∞–ª–∞—Å—å –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É –¥—Ä—É–≥–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞.
"""


def make_silhouette_plot(
    sample_scores: np.ndarray,
    labels: np.ndarray,
    school_order: list[str],
    overall_score: float,
    metric: str,
) -> plt.Figure:
    fig, ax = plt.subplots(figsize=(8, 5))
    y_lower = 10
    colors = [plt.cm.tab10(i) for i in range(len(school_order))]

    for idx, school in enumerate(school_order):
        mask = labels == idx
        cluster_scores = sample_scores[mask]
        if cluster_scores.size == 0:
            continue
        cluster_scores = np.sort(cluster_scores)
        size = cluster_scores.size
        y_upper = y_lower + size
        ax.fill_betweenx(
            np.arange(y_lower, y_upper),
            0,
            cluster_scores,
            facecolor=colors[idx],
            alpha=0.7,
        )
        ax.text(
            -0.98,
            y_lower + size / 2,
            f"{school} (–∫–æ–ª-–≤–æ: {size})",
            fontsize=10,
            va="center",
        )
        y_lower = y_upper + 10

    ax.axvline(x=overall_score, color="gray", linestyle="--", linewidth=1.5)
    ax.set_xlim([-1, 1])
    ax.set_xlabel("–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–∏–ª—É—ç—Ç–∞")
    ax.set_ylabel("–î–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏")
    ax.set_title(f"–°–∏–ª—É—ç—Ç–Ω—ã–π –≥—Ä–∞—Ñ–∏–∫ (–º–µ—Ç—Ä–∏–∫–∞: {metric})")
    ax.set_yticks([])
    ax.grid(axis="x", linestyle=":", alpha=0.4)
    fig.tight_layout()
    return fig


# ====================== –ò–ù–¢–ï–†–§–ï–ô–° (–±–µ–∑ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ —Å–∞–π–¥–±–∞—Ä–∞) ============
try:
    df = load_data()
except Exception as e:
    st.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö: {e}")
    st.stop()

# –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏
missing = [c for c in [AUTHOR_COLUMN, *SUPERVISOR_COLUMNS] if c not in df.columns]
if missing:
    st.error("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –Ω—É–∂–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏: " + ", ".join(f"`{c}`" for c in missing))
    st.stop()

# –ò–Ω–¥–µ–∫—Å –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º
idx = build_index(df, SUPERVISOR_COLUMNS)

# –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –¥–ª—è –≤—ã–±–æ—Ä–∞
all_supervisor_names: Set[str] = set()
for col in SUPERVISOR_COLUMNS:
    all_supervisor_names.update({v for v in df[col].dropna().astype(str).unique() if v})

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ –∞–¥—Ä–µ—Å–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ (?root=...)
shared_roots = st.query_params.get_all("root")
valid_shared_roots = [r for r in shared_roots if r in all_supervisor_names]
manual_prefill = "\n".join(r for r in shared_roots if r not in all_supervisor_names)

tab_lineages, tab_dissertations, tab_profiles, tab_schoolcomparison = st.tabs(
    [
        "–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤—å–µ–≤",
        "–ü–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—è—Ö",
        "–ü–æ–∏—Å–∫ –ø–æ —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø—Ä–æ—Ñ–∏–ª—è–º",
        "–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞—É—á–Ω—ã—Ö —à–∫–æ–ª",
        #–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞—É—á–Ω—ã—Ö —à–∫–æ–ª. –í–∞—Ä–∏–∞–Ω—Ç 2"    
        ]
)

with tab_lineages:
    if st.button("üìñ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è", key="instruction_lineages"):
        show_instruction("lineages")
        
    st.subheader("–í—ã–±–æ—Ä –Ω–∞—É—á–Ω—ã—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–µ—Ä–µ–≤—å–µ–≤")
    roots = st.multiselect(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∏–º–µ–Ω–∞ –∏–∑ –±–∞–∑—ã",
        options=sorted(all_supervisor_names),
        default=valid_shared_roots,  # –µ—Å–ª–∏ –ø—Ä–∏—à–ª–∏ –ø–æ —Å—Å—ã–ª–∫–µ, –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ–º –∏–º–µ–Ω–∞
        help="–°–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –∏–∑ —Å—Ç–æ–ª–±—Ü–æ–≤ —Å —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º–∏",
    )
    manual = st.text_area(
        "–ò–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ –∏–º–µ–Ω–∞ –≤—Ä—É—á–Ω—É—é –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –§–∞–º–∏–ª–∏—è –ò–º—è –û—Ç—á–µ—Å—Ç–≤–æ (–ø–æ –æ–¥–Ω–æ–º—É –Ω–∞ —Å—Ç—Ä–æ–∫—É)",
        height=120,
        value=manual_prefill,
    )
    manual_list = [r.strip() for r in manual.splitlines() if r.strip()]
    roots = list(dict.fromkeys([*roots, *manual_list]))  # —É–±—Ä–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã, —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ—Ä—è–¥–æ–∫

    build_clicked = st.button("–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –¥–µ—Ä–µ–≤—å—è", type="primary", key="build_trees")
    if build_clicked or shared_roots:
        st.session_state["built"] = True
    build = st.session_state.get("built", False)

    tree_option_labels = [label for label, _, _ in TREE_OPTIONS]
    selected_tree_labels = st.multiselect(
        "–¢–∏–ø—ã –¥–µ—Ä–µ–≤—å–µ–≤ –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è",
        options=tree_option_labels,
        default=[tree_option_labels[0]],
        help="–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Å—Ç–µ–ø–µ–Ω–∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∫ –ø–µ—Ä–≤–æ–º—É —É—Ä–æ–≤–Ω—é –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è.",
    )
    selected_tree_labels = selected_tree_labels or [tree_option_labels[0]]
    selected_tree_configs = [opt for opt in TREE_OPTIONS if opt[0] in selected_tree_labels]
    export_md_outline = st.checkbox("–¢–∞–∫–∂–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ (.md)", value=False)

    if build:
        if not roots:
            st.warning("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–º—è —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è.")
        else:
            all_zip_buf = io.BytesIO()
            zf = zipfile.ZipFile(all_zip_buf, mode="w", compression=zipfile.ZIP_DEFLATED)

            for root in roots:
                st.markdown("---")
                st.subheader(f"‚ñ∂ {root}")

                tree_results = []
                for label, suffix, first_level_filter in selected_tree_configs:
                    G, subset = lineage(
                        df, idx, root, first_level_filter=first_level_filter
                    )
                    tree_results.append(
                        {
                            "label": label,
                            "suffix": suffix,
                            "graph": G,
                            "subset": subset,
                        }
                    )

                root_slug = slug(root)
                person_entries: List[tuple[str, bytes]] = []
                has_content = False

                for tree in tree_results:
                    label = tree["label"]
                    suffix = tree["suffix"]
                    G = tree["graph"]
                    subset = tree["subset"]

                    if G.number_of_edges() == 0:
                        st.info(
                            f"{label}: –ø–æ—Ç–æ–º–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –¥–µ—Ä–µ–≤–∞."
                        )
                        continue

                    has_content = True
                    st.markdown(f"#### üå≥ {label}")

                    fig = draw_matplotlib(G, root)
                    png_buf = io.BytesIO()
                    fig.savefig(png_buf, format="png", dpi=300, bbox_inches="tight")
                    png_bytes = png_buf.getvalue()

                    st.image(png_bytes, caption="–ú–∏–Ω–∏–∞—Ç—é—Ä–∞ PNG", width=220)

                    html = build_pyvis_html(G, root)
                    st.components.v1.html(html, height=800, width=2000, scrolling=True)
                    html_bytes = html.encode("utf-8")

                    csv_bytes = subset.to_csv(
                        index=False, encoding="utf-8-sig"
                    ).encode("utf-8-sig")

                    md_bytes = None
                    if export_md_outline:
                        out_lines: List[str] = []

                        def walk(n: str, d: int = 0) -> None:
                            out_lines.append(f"{'  ' * d}- {n}")
                            for c in G.successors(n):
                                walk(c, d + 1)

                        walk(root)
                        md_bytes = ("\n".join(out_lines)).encode("utf-8")

                    file_prefix = (
                        root_slug if suffix == "general" else f"{root_slug}.{suffix}"
                    )

                    c1, c2, c3, c4 = st.columns(4)
                    with c1:
                        st.download_button(
                            "–°–∫–∞—á–∞—Ç—å PNG",
                            data=png_bytes,
                            file_name=f"{file_prefix}.png",
                            mime="image/png",
                            key=f"png_{file_prefix}",
                        )
                    with c2:
                        st.download_button(
                            "–°–∫–∞—á–∞—Ç—å HTML",
                            data=html_bytes,
                            file_name=f"{file_prefix}.html",
                            mime="text/html",
                            key=f"html_{file_prefix}",
                        )
                    with c3:
                        if st.button("üì• –¢–∞–±–ª–∏—Ü–∞ –¥–∞–Ω–Ω—ã—Ö", key=f"data_{file_prefix}"):
                            download_data_dialog(subset, f"{file_prefix}.sampling", f"tree_{file_prefix}")
                    with c4:
                        if md_bytes is not None:
                            st.download_button(
                                "–°–∫–∞—á–∞—Ç—å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ .md",
                                data=md_bytes,
                                file_name=f"{file_prefix}.xmind.md",
                                mime="text/markdown",
                                key=f"md_{file_prefix}",
                            )
                        else:
                            st.empty()

                    person_entries.append((f"{file_prefix}.png", png_bytes))
                    person_entries.append((f"{file_prefix}.html", html_bytes))
                    person_entries.append((f"{file_prefix}.sampling.csv", csv_bytes))
                    zf.writestr(f"{file_prefix}.png", png_bytes)
                    zf.writestr(f"{file_prefix}.html", html_bytes)
                    zf.writestr(f"{file_prefix}.sampling.csv", csv_bytes)
                    if md_bytes is not None:
                        person_entries.append((f"{file_prefix}.xmind.md", md_bytes))
                        zf.writestr(f"{file_prefix}.xmind.md", md_bytes)

                if not has_content:
                    continue

                person_zip: bytes | None = None
                if person_entries:
                    person_zip_buf = io.BytesIO()
                    try:
                        with zipfile.ZipFile(
                            person_zip_buf,
                            mode="w",
                            compression=zipfile.ZIP_DEFLATED,
                        ) as z_person:
                            for filename, data in person_entries:
                                z_person.writestr(filename, data)
                        person_zip = person_zip_buf.getvalue()
                    except Exception:
                        person_zip = None

                col_zip_person, col_share_person = st.columns([3, 1])
                with col_zip_person:
                    if person_zip is not None:
                        st.download_button(
                            label="‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å –≤—Å—ë –∞—Ä—Ö–∏–≤–æ–º (ZIP)",
                            data=person_zip,
                            file_name=f"{root_slug}.zip",
                            mime="application/zip",
                            key=f"zip_{root_slug}",
                        )
                with col_share_person:
                    share_button([root], key=f"share_{root_slug}")

            zf.close()
            if all_zip_buf.getbuffer().nbytes > 0:
                col_zip, col_share = st.columns([3, 1])
                with col_zip:
                    st.download_button(
                        label="‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å –≤—Å—ë –∞—Ä—Ö–∏–≤–æ–º (ZIP)",
                        data=all_zip_buf.getvalue(),
                        file_name="lineages_export.zip",
                        mime="application/zip",
                    )
                with col_share:
                    share_button(roots, key="share_all")
    else:
        st.info(
            "–í—ã–±–µ—Ä–∏—Ç–µ –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ –∏–º–µ–Ω–∞ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –∏ –Ω–∞–∂–º–∏—Ç–µ ‚Äò–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –¥–µ—Ä–µ–≤—å—è‚Äô."
        )

#with tab_silhouette: –ó–¥–µ—Å—å –±—ã–ª –∫–æ–¥ –≤–∫–ª–∞–¥–∫–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –Ω–∞—É—á–Ω—ã—Ö —à–∫–æ–ª

with tab_dissertations:
    if st.button("üìñ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è", key="instruction_dissertations"):
        show_instruction("dissertations")
        
    st.subheader("–ü–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—è—Ö")
    st.write(
        """
        –ù–∞ —ç—Ç–æ–π –≤–∫–ª–∞–¥–∫–µ –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ–∏—Å–∫ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π –ø–æ —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º.
        """
    )
    
    # –ü–æ–ª—É—á–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –≤—ã–ø–∞–¥–∞—é—â–∏—Ö —Å–ø–∏—Å–∫–æ–≤
    all_years = sorted([str(y) for y in df["year"].dropna().unique() if str(y).strip()], reverse=True)
    all_cities = sorted([str(c) for c in df["city"].dropna().unique() if str(c).strip()])
    
    # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏
    all_specialties = set()
    for col in ["specialties_1.code", "specialties_1.name", "specialties_2.code", "specialties_2.name"]:
        if col in df.columns:
            vals = df[col].dropna().unique()
            all_specialties.update([str(v).strip() for v in vals if str(v).strip()])
    all_specialties = sorted(all_specialties)
    
    # –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏ –ø–æ–∏—Å–∫–∞
    available_criteria = {
        "title": "–ù–∞–∑–≤–∞–Ω–∏–µ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏",
        "candidate_name": "–§–ò–û –∞–≤—Ç–æ—Ä–∞",
        "supervisors": "–§–ò–û –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è",
        "opponents": "–§–ò–û –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞",
        "institution_prepared": "–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è",
        "leading_organization": "–í–µ–¥—É—â–∞—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è",
        "defense_location": "–ú–µ—Å—Ç–æ –∑–∞—â–∏—Ç—ã",
        "city": "–ì–æ—Ä–æ–¥ –∑–∞—â–∏—Ç—ã",
        "year": "–ì–æ–¥ –∑–∞—â–∏—Ç—ã",
        "specialties": "–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å"
    }
    
    st.markdown("### 1. –í—ã–±–æ—Ä –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤ –ø–æ–∏—Å–∫–∞")
    selected_criteria = st.multiselect(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏ –ø–æ–∏—Å–∫–∞ (–º–∞–∫—Å–∏–º—É–º 5 –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)",
        options=list(available_criteria.keys()),
        format_func=lambda x: available_criteria[x],
        max_selections=5,
        key="dissertation_search_criteria"
    )
    
    if not selected_criteria:
        st.info("–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∫—Ä–∏—Ç–µ—Ä–∏–π –¥–ª—è –ø–æ–∏—Å–∫–∞.")
    else:
        st.markdown("### 2. –í–≤–æ–¥ –¥–∞–Ω–Ω—ã—Ö")
        search_params = {}
        
        for criterion in selected_criteria:
            if criterion == "year":
                search_params[criterion] = st.selectbox(
                    available_criteria[criterion],
                    options=["–í—Å–µ"] + all_years,
                    key=f"diss_search_{criterion}"
                )
            elif criterion == "city":
                search_params[criterion] = st.selectbox(
                    available_criteria[criterion],
                    options=["–í—Å–µ"] + all_cities,
                    key=f"diss_search_{criterion}"
                )
            elif criterion == "specialties":
                search_params[criterion] = st.selectbox(
                    available_criteria[criterion],
                    options=["–í—Å–µ"] + all_specialties,
                    key=f"diss_search_{criterion}"
                )
            else:
                search_params[criterion] = st.text_input(
                    available_criteria[criterion],
                    placeholder=f"–í–≤–µ–¥–∏—Ç–µ {available_criteria[criterion].lower()}...",
                    key=f"diss_search_{criterion}"
                )
        
        st.markdown("### 3. –†–µ–∑—É–ª—å—Ç–∞—Ç")
        
        if st.button("–ù–∞–π—Ç–∏", type="primary", key="dissertation_search_button"):
            result_df = df.copy()
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
            for criterion, value in search_params.items():
                if not value or value == "–í—Å–µ":
                    continue
                
                if criterion in ["title", "candidate_name", "institution_prepared", 
                               "leading_organization", "defense_location"]:
                    result_df = result_df[result_df[criterion].astype(str).str.contains(value, case=False, na=False)]
                
                elif criterion == "supervisors":
                    mask = pd.Series([False] * len(result_df), index=result_df.index)
                    for col in ["supervisors_1.name", "supervisors_2.name"]:
                        if col in result_df.columns:
                            mask |= result_df[col].astype(str).str.contains(value, case=False, na=False)
                    result_df = result_df[mask]
                
                elif criterion == "opponents":
                    mask = pd.Series([False] * len(result_df), index=result_df.index)
                    for col in ["opponents_1.name", "opponents_2.name", "opponents_3.name"]:
                        if col in result_df.columns:
                            mask |= result_df[col].astype(str).str.contains(value, case=False, na=False)
                    result_df = result_df[mask]
                
                elif criterion in ["city", "year"]:
                    result_df = result_df[result_df[criterion].astype(str).str.contains(value, case=False, na=False)]
                
                elif criterion == "specialties":
                    mask = pd.Series([False] * len(result_df), index=result_df.index)
                    for col in ["specialties_1.code", "specialties_1.name", "specialties_2.code", "specialties_2.name"]:
                        if col in result_df.columns:
                            mask |= result_df[col].astype(str).str.contains(value, case=False, na=False)
                    result_df = result_df[mask]
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ session_state
            st.session_state["diss_search_result"] = result_df
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å –≤ session_state
        if "diss_search_result" in st.session_state:
            result_df = st.session_state["diss_search_result"]
            
            if result_df.empty:
                st.warning("–ü–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            else:
                st.success(f"–ù–∞–π–¥–µ–Ω–æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π: {len(result_df)}")
                
                # –ö–æ–ª–æ–Ω–∫–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                display_columns = []
                for col in ["Code", "candidate_name", "title", "year", "city", "institution_prepared", 
                           "defense_location", "supervisors_1.name", "supervisors_2.name",
                           "opponents_1.name", "opponents_2.name", "opponents_3.name",
                           "leading_organization", "specialties_1.code", "specialties_1.name",
                           "specialties_2.code", "specialties_2.name", "degree.degree_level", 
                           "degree.science_field"]:
                    if col in result_df.columns:
                        display_columns.append(col)
                
                rename_map = {
                    "Code": "–ö–æ–¥", "candidate_name": "–ê–≤—Ç–æ—Ä", "title": "–ù–∞–∑–≤–∞–Ω–∏–µ",
                    "year": "–ì–æ–¥", "city": "–ì–æ—Ä–æ–¥", "institution_prepared": "–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è",
                    "defense_location": "–ú–µ—Å—Ç–æ –∑–∞—â–∏—Ç—ã",
                    "supervisors_1.name": "–ù–∞—É—á–Ω—ã–π —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å 1",
                    "supervisors_2.name": "–ù–∞—É—á–Ω—ã–π —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å 2",
                    "opponents_1.name": "–û–ø–ø–æ–Ω–µ–Ω—Ç 1",
                    "opponents_2.name": "–û–ø–ø–æ–Ω–µ–Ω—Ç 2",
                    "opponents_3.name": "–û–ø–ø–æ–Ω–µ–Ω—Ç 3",
                    "leading_organization": "–í–µ–¥—É—â–∞—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è",
                    "specialties_1.code": "–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å 1 (–∫–æ–¥)",
                    "specialties_1.name": "–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å 1",
                    "specialties_2.code": "–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å 2 (–∫–æ–¥)",
                    "specialties_2.name": "–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å 2",
                    "degree.degree_level": "–°—Ç–µ–ø–µ–Ω—å",
                    "degree.science_field": "–û–±–ª–∞—Å—Ç—å –Ω–∞—É–∫–∏"
                }
                
                display_df = result_df[display_columns].rename(columns=rename_map)
                st.dataframe(display_df, use_container_width=True)
                
                # –ö–Ω–æ–ø–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è ‚Äî –¥–∞–Ω–Ω—ã–µ —Ç–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω—ã –∏–∑ session_state
                if st.button("üì• –°–∫–∞—á–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã", key="diss_show_download"):
                    download_data_dialog(result_df[display_columns], "dissertations_search", "diss")


with tab_profiles:
    if st.button("üìñ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è", key="instruction_profiles"):
        show_instruction("profiles")
        
    st.subheader("–ü–æ–∏—Å–∫ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π –ø–æ —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø—Ä–æ—Ñ–∏–ª—è–º")
    st.write(
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–æ –ø—è—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ—Ñ–∏–ª–µ–π. –í "
        "–ø–æ–¥–±–æ—Ä–∫—É –ø–æ–ø–∞–¥—É—Ç –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏, —É –∫–æ—Ç–æ—Ä—ã—Ö –±–∞–ª–ª—ã –ø–æ –∫–∞–∂–¥–æ–º—É –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö "
        f"–ø—É–Ω–∫—Ç–æ–≤ –Ω–µ –Ω–∏–∂–µ {PROFILE_MIN_SCORE}, –∞ —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏–µ –±—É–¥–µ—Ç –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å –ø–æ "
        "—Å—É–º–º–µ –±–∞–ª–ª–æ–≤."
    )

    if PROFILE_SELECTION_SESSION_KEY not in st.session_state:
        st.session_state[PROFILE_SELECTION_SESSION_KEY] = []

    selected_codes: List[str] = list(
        st.session_state.get(PROFILE_SELECTION_SESSION_KEY, [])
    )

    selection_container = st.container()
    with selection_container:
        st.markdown("#### –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞")
        options: List[Optional[ClassifierItem]] = [None, *THEMATIC_CLASSIFIER]
        choice = st.selectbox(
            "–≠–ª–µ–º–µ–Ω—Ç –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞",
            options=options,
            format_func=classifier_format,
            key="profile_classifier_choice",
        )

        add_reason: Optional[str] = None
        add_code: Optional[str] = None
        if choice is not None:
            add_code = choice[0]
            if choice[2]:
                add_reason = "–≠—Ç–æ—Ç –ø—É–Ω–∫—Ç —è–≤–ª—è–µ—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω—ã–º –∏ –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—Ç –≤ –ø–æ–¥–±–æ—Ä–∫–µ."
            elif add_code in selected_codes:
                add_reason = "–ü—É–Ω–∫—Ç —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å–ø–∏—Å–æ–∫."
            elif len(selected_codes) >= PROFILE_SELECTION_LIMIT:
                add_reason = (
                    f"–ú–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –Ω–µ –±–æ–ª–µ–µ {PROFILE_SELECTION_LIMIT} –ø—É–Ω–∫—Ç–æ–≤ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞."
                )

        add_disabled = add_code is None or add_reason is not None
        add_clicked = st.button(
            "–î–æ–±–∞–≤–∏—Ç—å –≤ –ø–æ–¥–±–æ—Ä–∫—É",
            disabled=add_disabled,
            key="profile_add_button",
        )

        if add_clicked and add_code is not None:
            updated = [*selected_codes, add_code]
            st.session_state[PROFILE_SELECTION_SESSION_KEY] = updated
            selected_codes = updated

        if add_reason and choice is not None:
            st.caption(add_reason)

    st.markdown("#### –í—ã–±—Ä–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏")
    if selected_codes:
        st.caption(
            f"–£—á—Ç—ë–º –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏, —É –∫–æ—Ç–æ—Ä—ã—Ö –±–∞–ª–ª—ã ‚â• {PROFILE_MIN_SCORE} –ø–æ –∫–∞–∂–¥–æ–º—É –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É –ø—É–Ω–∫—Ç—É."
        )
        for code in list(selected_codes):
            cols = st.columns([0.85, 0.15])
            with cols[0]:
                st.markdown(f"‚Ä¢ **{classifier_label(code)}**")
            with cols[1]:
                if st.button(
                    "–£–¥–∞–ª–∏—Ç—å",
                    key=f"profile_remove_{code}",
                    use_container_width=True,
                ):
                    updated = [c for c in selected_codes if c != code]
                    st.session_state[PROFILE_SELECTION_SESSION_KEY] = updated
                    selected_codes = updated
                    _trigger_rerun()

        col_clear, col_dummy = st.columns([0.2, 0.8])
        with col_clear:
            if st.button("–û—á–∏—Å—Ç–∏—Ç—å –≤—ã–±–æ—Ä", key="profile_clear_selection"):
                st.session_state[PROFILE_SELECTION_SESSION_KEY] = []
                selected_codes = []
                _trigger_rerun()
    else:
        st.info(
            "–î–æ–±–∞–≤—å—Ç–µ –æ—Ç –æ–¥–Ω–æ–≥–æ –¥–æ –ø—è—Ç–∏ –ø—É–Ω–∫—Ç–æ–≤ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞, —á—Ç–æ–±—ã —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø–æ–¥–±–æ—Ä–∫—É."
        )

    # –ö–Ω–æ–ø–∫–∞ –∑–∞–ø—É—Å–∫–∞ –ø–æ–∏—Å–∫–∞
    run_search_click = st.button(
        "–ù–∞–π—Ç–∏ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏",
        type="primary",
        disabled=not selected_codes,
        key="profile_run_search",
    )

    # –õ–æ–≥–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è: –µ—Å–ª–∏ –Ω–∞–∂–∞–ª–∏ –∫–Ω–æ–ø–∫—É, –∑–∞–ø–æ–º–∏–Ω–∞–µ–º —ç—Ç–æ
    if run_search_click:
        st.session_state["profile_search_active"] = True

    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—á–∏—Å—Ç–∏–ª –∫–æ–¥—ã, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–∏—Å–∫–∞
    if not selected_codes:
        st.session_state["profile_search_active"] = False

    # –£—Å–ª–æ–≤–∏–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è: –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ –∫–Ω–æ–ø–∫—É, –∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    if st.session_state.get("profile_search_active") and selected_codes:
        try:
            scores_df = load_basic_scores()
        except Exception as exc:
            st.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ—Ñ–∏–ª–∏: {exc}")
            scores_df = None

        if scores_df is not None:
            missing_columns = [
                code for code in selected_codes if code not in scores_df.columns
            ]
            if missing_columns:
                st.error(
                    "–í —Ñ–∞–π–ª–∞—Ö —Å —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–æ—Ñ–∏–ª—è–º–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —Å—Ç–æ–ª–±—Ü—ã: "
                    + ", ".join(f"`{c}`" for c in missing_columns)
                )
            else:
                working = scores_df[["Code", *selected_codes]].copy()
                for code in selected_codes:
                    working = working[working[code] >= PROFILE_MIN_SCORE]

                if working.empty:
                    st.info(
                        "–ù–µ –Ω–∞–π–¥–µ–Ω–æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –∑–∞–¥–∞–Ω–Ω—ã–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º."
                    )
                else:
                    working["profile_total"] = working[selected_codes].sum(axis=1)
                    sort_columns = ["profile_total", *selected_codes]
                    working = working.sort_values(
                        by=sort_columns,
                        ascending=[False] * len(sort_columns),
                    )

                    info_columns = [
                        "Code",
                        "candidate_name",
                        "title",
                        "year",
                        "degree.degree_level",
                        "degree.science_field",
                        "institution_prepared",
                        "supervisors_1.name",
                        "supervisors_2.name",
                        "specialties_1.name",
                        "specialties_2.name",
                    ]
                    available_info_columns = [
                        col for col in info_columns if col in df.columns
                    ]
                    if available_info_columns:
                        info_df = (
                            df[available_info_columns]
                            .copy()
                            .drop_duplicates(subset="Code", keep="first")
                        )
                    else:
                        info_df = pd.DataFrame(columns=["Code"])

                    results = working.merge(info_df, on="Code", how="left")
                    results["profile_total"] = results["profile_total"].round(2)

                    score_labels = {code: classifier_label(code) for code in selected_codes}
                    for code, label in score_labels.items():
                        results[label] = results[code].round(2)

                    supervisor_cols = [
                        col
                        for col in ["supervisors_1.name", "supervisors_2.name"]
                        if col in results.columns
                    ]

                    if supervisor_cols:
                        def _join_names(row: pd.Series) -> str:
                            names = []
                            for value in row.tolist():
                                if isinstance(value, str):
                                    clean = value.strip()
                                    if clean and clean not in names:
                                        names.append(clean)
                            return ", ".join(names)

                        results["–ù–∞—É—á–Ω—ã–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏"] = (
                            results[supervisor_cols]
                            .replace({"": pd.NA})
                            .apply(_join_names, axis=1)
                        )

                    rename_map = {
                        "Code": "–ö–æ–¥ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏",
                        "candidate_name": "–ê–≤—Ç–æ—Ä",
                        "title": "–ù–∞–∑–≤–∞–Ω–∏–µ",
                        "year": "–ì–æ–¥ –∑–∞—â–∏—Ç—ã",
                        "degree.degree_level": "–°—Ç–µ–ø–µ–Ω—å",
                        "degree.science_field": "–û—Ç—Ä–∞—Å–ª—å –Ω–∞—É–∫–∏",
                        "institution_prepared": "–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è",
                        "specialties_1.name": "–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å",
                        "specialties_2.name": "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å",
                        "profile_total": "–°—É–º–º–∞—Ä–Ω—ã–π –±–∞–ª–ª",
                    }

                    column_order = [
                        "Code",
                        "candidate_name",
                        "title",
                        "year",
                        "degree.degree_level",
                        "degree.science_field",
                        "institution_prepared",
                        "–ù–∞—É—á–Ω—ã–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏",
                        "specialties_1.name",
                        "specialties_2.name",
                        "profile_total",
                        *score_labels.values(),
                    ]
                    display_columns = [
                        col for col in column_order if col in results.columns
                    ]
                    display_df = results[display_columns].rename(columns=rename_map)

                    # --- –ë–õ–û–ö –§–ò–õ–¨–¢–†–ê–¶–ò–ò ---
                    st.markdown("---")
                    
                    f_col1, f_col2 = st.columns([0.6, 0.4])
                    with f_col1:
                        search_query = st.text_input(
                            "üîç –§–∏–ª—å—Ç—Ä –ø–æ —Ç–∞–±–ª–∏—Ü–µ",
                            placeholder="–í–≤–µ–¥–∏—Ç–µ –∞–≤—Ç–æ—Ä–∞, –≥–æ–¥ –∏–ª–∏ —á–∞—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è...",
                            help="–°—Ç—Ä–æ–∫–∏, –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –≤–≤–µ–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç, –±—É–¥—É—Ç —Å–∫—Ä—ã—Ç—ã.",
                            key="profile_result_filter"
                        )
                    
                    if search_query:
                        mask = display_df.astype(str).apply(
                            lambda x: x.str.contains(search_query, case=False, na=False)
                        ).any(axis=1)
                        filtered_df = display_df[mask]
                    else:
                        filtered_df = display_df

                    if len(filtered_df) != len(display_df):
                        st.success(f"–ù–∞–π–¥–µ–Ω–æ –≤—Å–µ–≥–æ: {len(display_df)}. –ü–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: {len(filtered_df)}")
                    else:
                        st.success(f"–ù–∞–π–¥–µ–Ω–æ –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–π: {len(display_df)}")
                    
                    st.dataframe(filtered_df, use_container_width=True)

                    selection_slug = slug("_".join(selected_codes)) or "profiles"
                    if st.button("üì• –°–∫–∞—á–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã", key="profile_show_download"):
                        download_data_dialog(filtered_df, f"profiles_{selection_slug}", "profile")
                        
with tab_schoolcomparison:
    # –°–ª–æ–≤–∞—Ä—å {–∫–æ–¥: –Ω–∞–∑–≤–∞–Ω–∏–µ} –∏–∑ THEMATIC_CLASSIFIER
    classifier_labels = {code: title for code, title, _ in THEMATIC_CLASSIFIER}
    
    render_school_comparison_tab(
        df=df,
        idx=idx,
        lineage_func=lineage,
        rows_for_func=rows_for,
        scores_folder="basic_scores",        # ‚Üê –ü–∞–ø–∫–∞ —Å –ø—Ä–æ—Ñ–∏–ª—è–º–∏
        specific_files=None,                  # ‚Üê None = –≤—Å–µ CSV, –∏–ª–∏ ["file1.csv", "file2.csv"]
        classifier_labels=classifier_labels,  # ‚Üê –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –Ω–∞–∑–≤–∞–Ω–∏—è —É–∑–ª–æ–≤
    )

#with tab_schoolcomparison_new:
#    # –°–ª–æ–≤–∞—Ä—å {–∫–æ–¥: –Ω–∞–∑–≤–∞–Ω–∏–µ} –∏–∑ THEMATIC_CLASSIFIER
#    classifier_labels = {code: title for code, title, _ in THEMATIC_CLASSIFIER}
#    
#    render_school_comparison_new_tab(
#        df=df,
#        idx=idx,
#        lineage_func=lineage,
#        rows_for_func=rows_for,
#        scores_folder="basic_scores",        # ‚Üê –ü–∞–ø–∫–∞ —Å –ø—Ä–æ—Ñ–∏–ª—è–º–∏
#        specific_files=None,                  # ‚Üê None = –≤—Å–µ CSV, –∏–ª–∏ ["file1.csv", "file2.csv"]
#        classifier_labels=classifier_labels,  # ‚Üê –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –Ω–∞–∑–≤–∞–Ω–∏—è —É–∑–ª–æ–≤
#    )
